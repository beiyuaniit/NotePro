## 常用的状态码

200，请求正常处理；301，重定向；401未授权；403访问拒绝；404未找到资源；500服务器内部错误。4开头的状态码，后端接口接正确时，一般时前端出问题；5开头的状态码，一般都是后端的问题。

## 垃圾回收，JVM常用参数

将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停

对新生代的对象收集称为minor GC

对老生代的对象收集称为full GC

程序中主动调用System.gc()强制执行的GC为full GC。

Xms堆内存的最小大小，默认为物理内存的1/64

Xmx堆内存的最大大小，默认为物理内存的1/4

Xmn堆内新生代的大小，通过这个值也可以得到老生代的大小：Xmx减去Xmn。

## TCP传输可靠性怎么保证怎么保证

01、字节编号机制，为了更好的发送和接收；

02、数据段的确认机制，确认应答机制；

03、TCP超时重传机制，保证传输可靠性的一种重要保证。

## TCP握手为什么不能是2次

（1）主要是为了防止已经失效的连接请求报文突然又传动到了服务器，从而导致不必要的错误和资源的浪费。

（2）两次握手只能保证单项连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方发送的数据。

## int和byte能否相互转换，强制转换会有精度损失

可以相互转换，byte占1字节，而int占用4个字节，不会照成精度损失。

## 数组和链表的区别

数组是连续的内存空间，适合通过索引查找，查找和修改比较方便；链表不一定是连续的内存空间，添加和删除比较方便。

## 红黑树的特点

解决平衡二叉查找树的缺点：不适合需要大量插入、删除和查找的场景，需要左旋和右旋来保证平衡，引入红黑树，每条路径的黑色节点数相同，红色节点不能相同，时间复杂度O(logn)。红黑树的特性：红黑树是近似平衡的二叉查找树，支持高效的查找、插入和删除元素，查找删除和插入的效率稳定。红黑树更适合应对实际开发过程中的复杂场景。

## 父节点为红，子节点还能是红色吗

不可以，需要把红色节点先变成黑色。

## 排序算法哪些是稳定的，稳定性体现在相同数字在排序之后后面的不会出现到前面

稳定算法：插入排序、冒泡排序、归并排序、基数排序；不稳定算法：希尔排序、选择排序、堆排序、快速排序。

## 常用的锁有哪些

互斥锁、自旋锁、读写锁、乐观锁与悲观锁

## 三大范式

第一范式：要求一张表中的每一列是不可分割的原子数据

第二范式：消除部分依赖，要求一张表中的每一列都完全依赖于主键（针对于组合主键），也就是不会出现某一列只和部分主键相关；

第三范式：消除传递依赖，要求一张表中的每一列都和主键是直接依赖的，不是间接依赖。

## 数据库乐观锁和悲观锁，如何实现？

悲观锁：

①悲观锁总是认为数据会被其他线程修改，所以在修改前强制加锁，使其他线程阻塞等待，具有强烈的独占和排他特性。

②传统的关系型数据库的行锁，表锁，读锁，写锁等，以及Java中synchronized关键字都是悲观锁的实现。

③悲观锁比较适用于写多读少的情况（多写场景）。

乐观锁：

①乐观锁认为在一般情况下数据不会被其他线程修改，所以在修改前不会加锁，而是在数据提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

②乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性，如加版本号字段、AtomicInteger类的CAS（比较并交换）、MySQL中InnoDB的MVCC（多版本控制）机制等都是乐观锁的实现。

③乐观锁比较适用于读多写少的情况（多读场景）。

## 数据库的主键是怎么设置的？

通过primary key关键字来指定。

## 设计模式有哪些？单例模式、工厂模式，单例模式怎么实现？spring中的单例模式和普通单例模式有什么区别？

单例模式：枚举实现、静态内部类实现、利用Spring的依赖注入能力实现单例、双重检查锁。Spring中的单例模式和普通单例模式的区别：spring中的单例是相对于容器，即在ApplicationContext中是单例的。而平常所说的单例是相对于JVM的。另一个JVM可以有多个Spring容器，而且Spring中的单例也只是按bean的id来区分的。

## 线程的创建方式：

三种方式：①继承thread类，②实现Runnable()接口，都是重写Run方法；③通过Callable和Future创建线程，实现call方法。



## 线程池的七大参数：

corePollSize：核心线程数；maximumPoolSize：最大线程数；keepAliveTime：空闲线程存活时间；TimeUnit: 时间单位；BlockingQueue: 线程池任务队列；ThreadFactory: 创建线程工厂；RejectedExecutionHandler: 拒绝策略

19、线程池的工作流程：

![img](https://pic4.zhimg.com/80/v2-b8d002ca29d4830ba0bcbd356ffb3d17_720w.webp)

## sleep和wait的区别

都是用来进行线程控制，他们最大本质的区别是：sleep不释放同步锁，使用时间自动唤醒，可以用interrupt()来强行打断；wait释放同步锁，可以直接用notify()直接唤醒；sleep是thread类的静态方法。1，这两个方法来自不同的类分别是Thread和Object 2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。3，wait，notify和notify All只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

## spring的IOC和AOP的理解

IOC，即控制反转，把对象的创建、初始化、销毁交给Spring来管理

AOP，面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。通俗的说就是不用修改源代码，在主干功能里面添加新功能。

## spring中的bean单例和多例，以及为什么用多例，什么情况下使用多例

对象含有可改变状态时，则使用多例（如数据对象，否则使用单例；单例可以提高性能。（如配置类

## 单例模式怎么保证线程安全，volatile是防止指令重排

①加锁；②静态对象在类加载中被初始化了，loadClass对象加了锁

## MySQL一条语句查询慢是什么原因以及如何排查

原因：①电脑系统内存不足；②网络突然降速了；③所写的SQL语句不是最优解

解决方案：两条快于一条；精准快于全表；建立索引；

## spring和spring boot的区别

（1）spring boot提供极其快速和简化的操作，让Spring开发者快速上手

（2）spring boot提供了spring运行的默认配置

（3）spring boot为通用spring项目提供了很多的非功能性特性

## mybatis的取参方式，传参方式

有两种取参方式：${}和#{}；${}本质是字符串拼接，若为字符串或者日期类型的话需要使用单引号；#{}本质是占位符赋值，若为字符串类型或者日期类型时，可以自动添加单引号。

传参：①顺序传递，②@Param传递参数，③map集合传递参数，④JavaBean的实体类传递，⑤集合类型参数List传递。

## bean的注入方式

（1）Autowired注入方式、（2）构造方法注入、（3）@Bean方法形参注入、（4）直接在@Bean方法上使用@ConfigurationProperties（prefix=“jdbc”）

## spring的两大思想IOC和AOP，AOP的实现方式

IOC控制反转，将对象的创建交给Spring容器去创建，只需要在spring的配置文件里配置相应的 bean，以及设置相关的属性，让spring容器生成类的实例对象以及管理对象。不需要new，大大降低了代码间的耦合度，使资源更加容易管理。

AOP，面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。通俗的说就是不用修改源代码，在主干功能里面添加新功能。

AOP的实现方式，基于接口方式的实现；基于Aspectj的方式实现。

## springMVC的执行流程

1）用户向服务器发送请求，请求被springmvc前端控制器dispatcherSevlet捕获

2）DispatcherServlet对请求URL进行解析，得到请求资源标识符，判断请求URL对应的映射。

3）根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。

4）DispatcherServlet根据获得的handler，选择一个的handlerAdapter。

5）如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler()方法

6）提取request中的模型数据，填充Handler入参，开始执行Handler（Controller）方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作。

7）Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象

8）此时将开始执行拦截器的postHandler()方法

9）根据返回的ModelAndView选择合适的ViewResolver进行试图解析，根据Model和View，来渲染视图。

10）渲染视图完毕执行拦截器的afterCompletion（）方法。

11）将渲染结果返回给客户端。

## 序列化和反射是什么，序列化接口实现

反射指的是程序运行时透过反射API可以取得任何一个类的内部信息，包括修饰符、变量类型，返回类型，字段、方法等，并可以在运行时改变字段和唤醒方法。

序列化就是用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。为了解决在对对象进行读写操作时所引发的问题。

序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需 要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的， 然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对 象流)对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj)方 法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。

## 三大特性封装、继承、多态

1）封装是指把一个对象的状态(属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外部访问的方法来操作属性。

2）继承拓展已存在的代码模块，目的是为了代码复用。

3）多态：对象的编译时类型和运行时类型不一致，具体表现为父类的引用指向子类的实例。JAVA引用变量有两个类型（编译时类型和运行时类型）。其中，编译时类型由声明该变量时使用的类型（父类）决定，运行时类型由实际赋给该变量的对象决定（子类）。

## 接口和抽象类区别：

（1）抽象类要被子类继承，接口类要被类实现

（2）接口只能做方法声明，抽象类可以做方法实现

（3）接口里定义的变量只能是公共的静态常量，抽象类中的变量是普通变量

（4）接口是设计的结果，抽象类是重构的结果

（5）抽象类和接口都是用来抽象具体对象，接口的抽象级别最高

（6）抽象类可以有具体的方法和属性，接口只能抽象方法和不可变常量

（7）抽象类主要用来抽象类别，接口主要用来抽象功能

## JDK1.7和1.8接口的改变

Default关键字，接口中使用它定义方法体，实现类可以直接调用。

Lambda表达式，函数式编程，抽象程度很高的编程范式，纯粹的函数式编程语言编写函数没有变量。

函数式接口，局部变量限制。

## redis的两种持久化方式

（1）RDB将数据库中的数据定期以快照的方式存储到磁盘，保存到rdb中，并在启动时自动加载rdb文件，以达到持久化的需要；它的优点呢是数据恢复快，缺点是保存不是实时产生的。会在设置的时间内进行保存。

（2）AOF，把每一次的操作都记录到一个文件中，当redis进行重启时会将AOF文件中所有操作都执行一遍，确保恢复数据。需要开启，也有设置；优点是任何写的数据不会丢失，缺点是文件大，耗能高，数据恢复快，冗余多。

## redis中的删除策略：

定时删除（时间换空间）、惰性删除（内存占用严重、空间换时间）、定期删除（随机清理删除）

## ACID四大特性

原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性：数据库总是从一个一致性状态转移到另一个一致性的状态。一致性确保了即使在执行第三、第四条语句之间时系统崩溃，前面执行的第一、第二条语句也不会生效，因为事务最终没有提交，所有事务中所作的修改也不会保存到数据库中。

隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

持续性：指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## 四个隔离级别、MySQL的默认隔离级别：默认隔离级别是可重复读。

序列化：如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。

可重复读：在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。

提交读：READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。

未提交读：READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。

## 聚簇索引和非聚簇索引区别

聚簇索引：并不是一种单独的索引类型，而是一种数据存储方式。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB的聚簇索引实际上是将索引和数据保存中同一个B-Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

非聚簇索引：又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。

## left join和inner join：

左连接：在 LEFT JOIN 左边的表里面数据全被全部查出来，右边的数据只会查出符合ON后面的符合条件的数据，不符合的会用NULL代替。

内连接：相当于左连接与右连接的合并，去掉所有含NULL的数据行，剩下的就是查询出来的数据了。其实就是两边的表都必须满足条件。

##  线程和进程的区别：

（1）进程是资源分配的最小单位，线程是程序执行的最小单位

（2）进程有自己的独立地址空间，每启动一个进程，系统就会自动为它分配地址空间，建立数据库表来维护代码段、堆栈段和数据段；线程是共享进程中的数据，使用相同的地址空间，因此CPU切换一个线程花费要更小，同时创建线程的花费也更小。

（3）线程之间通信更方便，同一进程下的线程共享全局变量、静态变量等数据；而进程之间的通信是以通信的方式进行。多线程要解决同步和互斥问题；

（4）多进程程序更加健壮，多线程程序只要一个线程死掉，整个进程就会死掉；而一个进程死掉并不会对另一个进程造成影响。

## 线程的几种状态：

新建（new）：创建新线程、就绪（runnable）：调用线程start方法、运行（running）：获取cpu时间片，执行程序代码、阻塞（block）：等待阻塞，同步阻塞（synchronized），其他阻塞（sleep(),join()）、死亡（dead）：结束线程，或是异常退出，其实通过thread类可以知道到其实还有一种状态是terminal（中止）；线程首先被new创建，进入初始状态，然后线程调用start方法，进入就绪状态。这里要注意，线程只要抢占了cpu时间片，可以不用获取全部的锁就可以运行，但是当运行到需要的锁没有获得时，会进入阻塞状态。

当一个线程被sleep后，线程会先进入超时等待状态，当时间结束后，会先进入等待阻塞状态，当有锁以后再进入就绪状态。

## 线程池的实现方式

1、newCachedThreadPool类，创建一个线程池，如果线程池中的线程数量过大，它可以有效的回收多余的线程，如果线程不足，那么它可以创建新的线程。

2、newFixedThreadPool，这种方式可以指定线程池中的线程数。数满之后需要排队等候。

3、newScheduledThreadPool，该线程池支持定时，以及周期性的任务执行，我们可以延迟任务的执行时间，也可以设置一个周期性的时间让任务重复执行。

4、newSingleThreadExecutor，这是一个单线程，至始至终都由一个线程来执行。

5、ThreadPoolTaskExecutor，这是spring包下的，是spring为我们提供的线程池类。

46、线程池的拒绝处理策略：

ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务

## MQ了解吗:

Kafka

优点：吞吐量非常大，性能非常好，集群高可用。

缺点：会丢数据，功能比较单一

使用场景：日志分析、大数据采集

RebbitMQ

优点：消息可靠性高，功能全面。

缺点：吞吐量比较低，消息积累会严重影响性能。erlang语言不好定制。

使用场景：小规模场景。

RocketMQ （阿里产品）

优点：高吞吐、高性能、高可用，功能非常全面。

缺点：开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持java

使用场景：几乎是全场景。

