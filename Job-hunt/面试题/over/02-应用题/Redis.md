# ==Redis==

## 概述

- ﻿介绍
  - 本质一个Key-Value类型的内存数据库，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。
- 特点
  - 读写性能极高
    - 纯内存操作，Redis的性能非常出色
  - 支持数据持久化
    - 支持AOF和RDB两种持久化方式。
  - 支持事务
    - 通过MULTI和EXEC指令包起来。
  - 数据结构丰富
    - 除了支持string类型的value外，还支持hash、set、zset、list等数据结构。
  - 支持主从复制
    - 主机会自动将数据同步到从机，可以进行读写分离。
  - 丰富的特性
    - Redis还支持 publish/subscribe， 通知， key 过期等特性。
- 不足
  - 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写
  - 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。

## 数据类型

- 五大数据类型

  - String

    - Redis最基本的数据类型，一个Redis中字符串value最多可以是512M
    - 底层是一个简单的动态字符串，char数组，可以存储字符串，数字和二进制数据
    - 二进制安全的（只存原始二进制，不对特殊字符转义）。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象（有长度len存在，不已'\0'作为结尾符号
    - 采用预分配冗余空间的方式来减少内存的频繁分配
      - 当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间
    - tring在redis内部存储默认就是一个**字符串**，当遇到增减类操作incr，decr时会**转成数值型**进行计算。
    - redis所有的操作都是**原子性**的，采用**单线程**处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。
    - 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）

  - List

    - 字符串列表，存储线性有序且可重复的元素。对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差

    - 底层为双端的快速链表quickList

      - 压缩链表
      - 由一个个压缩列表ziplist配合双向指针完成，ziplist内部是一块连续的内存

    - 兼容链表的快速插入删除，也有数组的通过下标快速访问，也减少了指针的数目

      ![ziplist](B:\我的坚果云\面试题\images\ziplist.png)

  - Set

    - 无序集合
    - 底层用的是**intset（整数数组）**和**hashtable**。所有元素为整数时用inset存储；当元素的数量超过一定数量，默认512个，可设置，且为非整数时用hashtable
    - intset二分查找也还行吧
    - 可用于求差集，交集，并集等

  - Hash

    - 类似Java里面的Map<Key,Object>
    - Object是一组field=value的映射表
    - 当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable
      - 数组+链表/红黑树
      - 数组存储key 的hash值，通过数组定位key的hash值，此时可能有多个key映射到同一hash值，再通过链表或者红黑树找到key以及对应的value

  - ZSet

    - 有序集合，成员会关联一个评分score，可用于排序

    - 底层使用了两个数据结构**ziplist**和**skiplist**

      - 在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist，其他情况用hash+skiplist
      - ziplist（压缩链表
        - 用ziplist（压缩列表）时，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值，并按照分值进行排序
      - hashtable+skiplist（链表
        - hashtable的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。
          - 跳跃表
            - 跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。
        - 根据score排序吧
      
      ![跳跃表](B:\我的坚果云\面试题\images\跳跃表.png)

- 其他数据类型

  - Bitmaps
    - Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ，但是它可以对字符串的位进行操作
    - 应用：每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。
  - HyperLogLog
    - 用来做基数统计（求集合中不重复元素个数）的数据结构，
    - 优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。
  - Geospatial
    - 2维坐标，在地图上就是经纬度
    - 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作

## 持久化策略

- RDB（Redis DataBase）

  - 过程

    - Redis会单独创建（fork）一个子进程来进行持久化，会先将全部数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。dump.rdb

  - 优点

    - RDB是一个紧凑压缩的二进制文件，**存储效率较高**
    - RDB内部存储的是redis在某个时间点的数据快照，非常适合用于**数据备份，全量复制**等场景
    - RDB恢复数据的**速度**要比AOF**快**很多
  - 缺点
    - RDB方式无论是执行指令还是利用配置，**无法做到实时持久化**，具有较大的可能性丢失数据（最后一次修改
    - bgsave指令每次运行要执行fork操作**创建子进程**，要**牺牲**掉一些**性能**
    - Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式**无法兼容**现象
    - Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑
  - 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，**用于灾难恢复**
  
- AOF（Append Only File）

  - 概述
  - AOF(append only file)持久化：以独立日志的方式记录**每次**写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程
    - AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的**主流**方式
  - 过程
    - 以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录**)， **只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。appendonly.aof
      
    - 命令重写机制：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会fork子进程，进行AOF文件的内容压缩， 只保留可以恢·复数据的最小指令集.可以使用命令bgrewriteaof。如set a a和set b b可合并为set a a b b
  
  - 优点

    - 备份机制更稳健，丢失数据概率更低。
    - 备份速度更快
    
    - 可读的日志文本，通过操作AOF稳健，可以处理误操作。
    
  - 缺点
    - 比起RDB占用更多的磁盘空间。（指令中包含数据，指令本身也有额外开销
    - 恢复备份速度要慢。
    - 每次读写都同步的话，有一定的性能压力。
    - 若指令存在个别Bug，造成恢复不能。

- 选择

  - 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
  - 同时开启两种持久化方式
    - 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.
    - RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且AOF可能潜在的bug，



## 缓存穿透、击穿、雪崩

- 缓存穿透
  - 客户端大量访问缓存不存在的数据，使得请求直达存储层，导致负载过大，直至宕机。
  - 原因可能是业务层误删了缓存和库中的数据，或是有人恶意访问不存在的数据。
  - 解决方式：
    - 1.存储层未命中后，返回空值存入缓存层，客户端再次访问时，缓存层直接返回空值。
    - 2.将数据存入布隆过滤器，访问缓存之前经过滤器拦截，若请求的数据不存在则直接返回空值。 
      - 布隆过滤器思想
        - 利用 n 个哈希函数对一份数据进行 hash 过后，得到不同的哈希值，根据 hash 映射到数组（这个数组的长度可能会很长很长）的不同的索引位置上，然后将相应的索引位上的值设置为1
        - 判断该元素是否出现在集合中，就是利用k个不同的哈希函数计算哈希值，看哈希值对应相应索引位置上面的值是否是1，如果有一个是0，说明该元素不存在在集合中
        - 但是也有可能判断元素在集合中，但是元素不在，这个元素所有索引位置上面的1都是别的元素设置的，这就导致一定的误判几率（Hash冲突
    - 限制同时请求的数量，可以拿到令牌才能进行访问
- 缓存击穿：
  - 一份热点数据，它的访问量非常大，在它缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
  - 解决方案：1.永不过期：对热点数据不设置过期时间。2.加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。  3.限制同一时间的请求数量
- 缓存雪崩：
  - 大量数据同时过期、或是redis节点故障导致服务不可用，缓存层无法提供服务，所有的请求直达存储层，造成数据库宕机。
  - 解决方案：1.避免数据同时过期，设置随机过期时间。2.启用服务降级和熔断措施（不提供服务。3.设置热点数据永不过期。4.采用redis集群，一个宕机，另外的还能用，4 .限制请求数量

## 缓存预热

缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。

如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。

缓存预热解决方案：

* 数据量不大的时候，工程启动的时候进行加载缓存动作；

* 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；

* 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

## 缓存降级

缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

* 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；

* 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；

* 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；

* 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

## 与数据库保证双写一致性

- Redis数据库的数据在缓存，修改数据时，数据库，Redis要进行数据同步
- 四种方案：
  - 更新-更新 、删除-更新  或者反过来          考虑在两个操作之间中断了咋办
  - 先更新缓存，再更新数据库
    - 每次命中redis，拿到最新数据
    - 可能不会最终一致
  - 先更新数据库，再更新缓存。可能数据不一致
    - 最终一致
    - 但可能拿不到最新数据
  - 先删除redis，再更新数据库。可能丢失修改
  - 先更新数据库，再删除redis。可能数据不一致，删除出错可重试机制



## 实现分布式锁

- 主流实现方案
  - 基于数据库实现分布式锁
  - 基于缓存（Redis等）
  - 基于Zookeeper
- Redis
  - 解锁 ：del  k1
  - 加锁：
    - setnx  k1 abc                       //setnx   不存在才设置
      
      - 可能忘记解锁
      
    - setnx k1 abc      expiren k1 30            解锁 del  k1       //2个指令一起不是原子操作
      - 线程还在运行，锁就过期。
      - 使用Lua脚本（包含SETNX + EXPIRE两条指令），原子执行
      
    - set k1 abc nx ex 30    
      - A线程还在运行，锁就过期。  这个锁k1再被B线程拿到，此时 A会释放B的锁
      - 所以value用uuid等，判断其value是否和初始拿到的一致   
      
    - RedLock
    
      -  **Redis Distributed Lock;Redis实现的分布式锁**
    
      - 单点的Redis实现分布式锁基本上可以满足95%的业务场景。剩下的5%就是对数据一致性要求极其严苛并且对于锁丢失的0容忍的业务场景。这个时候就得考虑Redlock了
    
      - 假设存在多个Redis实例，这些节点是完全独立的，不需要使用复制或者任何协调数据的系统，我们假设有5个Redis master节点，客户端为了取到锁，步骤将会变成这样：
    
        - 以毫秒为单位获取当前的服务器时间
        - 尝试使用相同的key和随机值来获取锁，客户端对每一个机器获取锁时都应该有一个超时时间，比如锁的过期时间为10s，那么获取单个节点锁的超时时间就应该为5到50毫秒左右，他这样做的目的是为了保证客户端与故障的机器连接不耗费多余的时间！超时间时间内未获取数据就放弃该节点，从而去下一个Redis节点获取。
        - 获取完成后，获取当前时间减去步骤一获取的时间，当且仅当客户端从半数以上(这里是3个节点)的Redis节点获取到锁且获取锁的时间小于锁额超时时间，则证明该锁生效！
        - 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
        - 如果获取锁的机器不满足半数以上，或者锁的超时时间计算完毕后为负数等异常操作，则系统会尝试解锁所有实例，即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁
    
        所以我们看出，redlock其实是比单点Redis看起来更加可靠的锁。



## 单线程架构

- Redis采用的是单线程+IO多路复用技术。
  - 这里单线程指的是Redis中读写操作是由一个线程来完成的，但是其他操作时由其他线程完成的，例如：持久化操作、异步删除、集群数据同步等。
  - 单线程既可以简化数据结构和算法的实现，同时也消除了线程切换和竞争带来的消耗。Redis中采用的IO多路复用技术实现了单线程下同时处理多个IO请求。
    - 一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用
  - Redis6后这个IO则是另外一个线程，执行命令还是单线程
  - Redis为什么这么快：
    - 1）单线程进行读写，避免线程切换和锁竞争带来的消耗。
    - 2）Redis操作时在内存中进行的。
    - 3）最重要的就是采用了IO多路复用技术，实现了再网络IO中能够处理大量的并发请求，实现高吞吐量

## 高可用

- 在大型网络应用中，单个redis很难保证数据量的访问于存储，所以可以搭建分布式系统，保证数据的分撒储存与数据的一致性，实现redis的高可用。 
  - 主从复制（垂直方向扩展）：写一定是在主服务器上，然后主服务器同步给从服务器。缺点：当主服务器挂掉的时候，不能自动切换到从服务器上。主从服务器存储数据一样，内存可用性差。优点：在一定程度上分担主服务器读的压力。
    - 哨兵模式：构建多个哨兵节点监视主从服务器，当主服务器挂掉的时候，自动将对应的从服务器切换成主服务器。优点：实现自动切换，可用性高。缺点：主从服务器存储数据一致，内存可用性差。还要额外维护一套哨兵系统，较为麻烦。
      - 可以实现故障发现、故障自动转移、配置中心和客户端通知
  - 集群模式（水平方向扩展）：采用无中心节点的方式实现。底层可以多个主服务器相连，一个主服务器可以有多个从服务器，不同的主服务器存储不同的数据。优点：可用性更高，内存可用性高。（每个节点的压力更新，减轻单台服务器的压力

## 主从同步机制

- 主从同步分为全量同步和增量同步
  - 全量同步：从机第一次连接主机时不会携带主机id和数据偏移量，主机会对从机的主机id进行校验，如果不是则说明是第一次连接需要进行全量同步，原理就是将当前数据写到RDB文件发送给从机，从机接收到文件之后将数据读取到从机的内存中
  - 增量同步：第二次和之后连接才会发生，当从机第一次同步完成之后，主机在这期间数据发生变化，会将命令存储在缓冲区，当校验到从机的id正确时会获取从机的偏移量，主机从偏移量记录的命令开始将从机没同步的数据的操作命令发送给从机执行，执行完成后即完成了数据同步

## 缓存淘汰机制

- 惰性删除：客户端访问一个key的时候，redis先检查它的过期时间，如果已经过期了就立刻删除这个key ，并返回null
- 定时删除：redis会将设置了过期时间的key保存到一个字典里面，设置监听器，key过期后删除
  - LRU （最近最少使用原则）   
- 定期删除：每个一定时间扫描并清除过期的key

> 
