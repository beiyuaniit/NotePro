## 类之间的关系

- 关联性的强弱：依赖 <关联 <聚合 <组合 <实现 =泛化
- 依赖  （use a）
  - A的某方法参数、局部变量或者返回值  的类型是B
  - 临时性关系
  - 老师类和书类。（老师上课方法中用到了某本书
- 关联    （has a
  - A的某个成员变量类型是B
  - 不强调整体与部分，都是平等的独立个体。
  - 长久关系
  - 如订单类和客户类。（订单类的某个成员变量是客户类
- 聚合       
  - A的某个成员变量类型是B，B是A的部分（参与组成A），但B可以脱离A而存在
  - 强调整体与部分，但部分可以脱离整体而存在
  - 如汽车类和轮胎类。不在汽车中，轮胎至少还有意义
- 组合
  - A的某个成员变量类型是B，B是A的部分，B不可以脱离A而存在
  - 也强调部分和整体
  - 如汽车类和车门类。车门不在汽车中，就没有什么意义了
- 实现
  - A类实现了B接口。
  - A类具有B接口的功能，当然A类还能实现其他接口
- 泛化
  - 继承的反关系。父类泛化了子类
  - A类是B类的子类，具有B类的功能并进行了扩展。但是A类不能再继承其他类
  - is a

## 软件设计原则

- 为了提高软件可维护性、可复用性、可扩展性、灵活性
- 七大：开闭，依赖倒转，里氏替换，迪米特法则，单一职责，接口隔离，合成复用

- 开闭原则
  - 对扩展开放，对修改关闭。
  - 拓展时，不修改原有的代码，实现热插拔
  - 如软件的主题
    - 定义一个主题抽象类，每个具体的主题都继承这个抽象类
    - 用户可以根据自己的爱好更换不同的主题实现
  - 比依赖倒转更通用
    - 发布者广播一个信号，可以在不改变发布者的情况下增加订阅者
    - 信号根本不是订阅者的抽象，所以更应该是开闭原则

- 依赖倒转原则

  - 高层模块不应依赖于低层模块，二者依赖于抽象。抽象不依赖于细节，细节依赖于抽象（才能实现）
    - 举例子：高层应用应通过接口调用低层服务
  - 降低耦合、提高扩展性，复用性
  - 如电脑类和键盘类
    - 电脑类包含一个键盘接口，具体键盘实现这个接口
    - 可以很方便为电脑更换不同的键盘
  - 是开闭原则的一个实例
    - 键盘接口是键盘的抽象

- 里氏代换原则

  - 父类出现的地方，子类可以代换

  - 子类可扩展父类的功能，但不应该改变父类的原有方法

    - 原因：父类和子类方法是垂直关系。方法调用也是垂直的，重写父类方法会出现上下不一致问题
    - 解决：可选择实现接口，子类和子类之间方法是水平关系。

  - 如正方形不是长方形

    - 正方形是长方形的子类，为了赋值方便，正方形重写了长方形中的方法

      ```java
      //长方形
      setLength(double length) {this.length = length;}
      setWidth(double width) {this.width = width;}
      //正方形
      setWidth(double width) {
        	super.setLength(width);
          super.setWidth(width);
      }
      setLength(double length) {
          super.setLength(length);
          super.setWidth(length);
      }
      
      //在长方形（父类）能够运行的代码，正方形（子类）就可能出错
      //如让长方形的宽比长 的值更大
      //重写类父类方法的正常再运行这段代码就会死循环
      while (rectangle.getWidth() <= rectangle.getLength()) {
            rectangle.setWidth(rectangle.getWidth() + 1);
      }
      ```

- 单一职责原则
  - 每个模块的职责尽可能单一，被修改的次数就少
  - 让模块之间条理清晰，容易维护
- 接口隔离原则
  - 一个类对另一个类的依赖应该建立在最小的接口上
  - 若依赖一个很大的接口，那么且不需要某些方法，那么这个类的职责就不够明确了

- 迪米特法则（第三方）
  - 两个实体无需直接通信，那么不应发生直接调用，而是通多第三方通信。
  - 提高模块独立性
  - 如：粉丝通过经纪人来联系明星

- 合成复用原则
  - 复用时：优先使用关联、聚合、组合等，其次是继承
  - 弱关系能够很好保证各类的独立性，而强关系的继承会提高系统耦合度，不方便扩展



# ==创建型模式==

- 关注如何创建对象，将对象的创建和使用分离
- 分类
  - 单例模式
  - 工厂方法模式
  - 抽象工程模式
  - 原型模式
  - 建造者模式

## 单例设计模式

- 当不需要多个对象时，可只创建一个对象
- 好处
  
  - 只有一个对象，节省内存。不用频繁创建对象，提高性能
- 例子
  - spring的很多可复用组件，处理器handler，过滤器filter
  - 自己手写的jdbc连接类

- 实现

  - 饿汉式

    - 类加载时提前创建好

    ```java
    public class Singleton {
        //私有构造方法
        private Singleton() {}
    
        //在成员位置创建该类的对象
        private static Singleton instance = new Singleton();//创建的是本身
    
        //对外提供静态方法获取该对象
        public static Singleton getInstance() {
            return instance;
        }
    }
    ```

    - 枚举

    ```java
    //类加载时加载，只加载一次
    public enum Singleton {
        INSTANCE;
    }
    ```

  - 懒汉式

    - 用到时在创建
    - 锁

    ```java
    public class Singleton {
        //私有构造方法
        private Singleton() {}
    	//多线程下指令重排可能出现空指针
        private static volatile Singleton instance;
       //对外提供静态方法获取该对象
        public static Singleton getInstance() {
    		//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际
            if(instance == null) {
                //有很多线程进到这里了
                synchronized (Singleton.class) {
                    //抢到锁之后再次判断是否为空，第一抢到的才是空
                    if(instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
    ```

    - 静态内部类

    ```java
    public class Singleton {
        //私有构造方法
        private Singleton() {}
    	//类加载时不加载，使用时只加载一次
        private static class SingletonHolder {
            private static final Singleton INSTANCE = new Singleton();
        }
        //对外提供静态方法获取该对象
        public static Singleton getInstance() {
            return SingletonHolder.INSTANCE;
        }
    }
    ```

- 破坏单例模式

  - 反射时拿到的是一个新的对象

    - 反序列化也破坏，底层用到的是反射

  - 解决：

    - 单例类添加readResolve()方法

    ```java
    //定义了则返回这个方法的值，否则创建新对象    
    private Object readResolve() {
            return SingletonHolder.INSTANCE;
        }
    ```

    - 构造方法解决

    ```java
    //有原有对象则抛出异常。因为反射也是要调用构造方法   
    private Singleton() {
            if(instance != null) {
                throw new RuntimeException();
            }
        }
    ```

    

## 简单工厂模式（不是23种之一）

- 将创建对象和使用对象分离，增加可扩展性
  - 若
- 角色
  - 抽象产品 ：返回值类型
  - 具体产品 ：返回的产品
  - 具体工厂 ：方法返回同类的不同产品
- 

```java
public class SimpleCoffeeFactory {
	//方法一
    public static Coffee createCoffee(String type) {
        Coffee coffee = null;
        if("americano".equals(type)) {
            coffee = new AmericanoCoffee();
        } else if("latte".equals(type)) {
            coffee = new LatteCoffee();
        }
        return coffee;
    }
    //方法二
    public static Coffee getAmericano(){
        //也可以在这里封装创建对象的更多细节
        return new AmericanoCoffee();
    }
    public static Coffee getLatte(){
        return new LatteCoffee();
    }

}
```

- 优缺点
  - 优点
    - 实现简单，封装了创建对象的细节，可通过参数或不同方法返回不同的产品对象
    - 虽然不是23种模式之一，但是这个使用得比较多
  - 缺点
    - 增加或删除产品要修改已有工厂类代码

## 工厂模式

- 角色
  - 抽象工厂（Abstract Factory）： 
  - 具体工厂（ConcreteFactory）： 不同的工厂创建不同的产品
  - 抽象产品（Product）：返回值类型
  - 具体产品（ConcreteProduct）：返回的产品

- 3

```java
//抽象工厂
public interface CoffeeFactory {
    Coffee createCoffee();
}
//具体工厂
public class LatteCoffeeFactory implements CoffeeFactory {
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
}
public class AmericanCoffeeFactory implements CoffeeFactory {
    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}
```

- 优缺点
  - 优点
    - 增加或删除一个产品不用修改已有的工厂类
  - 缺点
    - 增加一个产品还是要增加一个具体的工厂类，增加了系统复杂度
- 例子
  - Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类。可通过Iterator获取迭代器

## 抽象工厂模式

- 角色
  - 抽象工厂（Abstract Factory）：定义了创建产品族的方法
  - 具体工厂（Concrete Factory）：创建产品族的具体实现
  - 抽象产品（Product）：方法返回值
  - 具体产品（ConcreteProduct）：返回的产品

- 

```java
//抽象工厂
public interface DessertFactory {

    Coffee createCoffee();

    Dessert createDessert();
}
//美式甜点工厂
public class AmericanDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }

    public Dessert createDessert() {
        return new MatchaMousse();
    }
}
//意大利风味甜点工厂
public class ItalyDessertFactory implements DessertFactory {
    public Coffee createCoffee() {
        return new LatteCoffee();
    }
    public Dessert createDessert() {
        return new Tiramisu();
    }
}
```



- 优缺点
  - 优点
    - 产品族中的产品被设计在一起工作时，调用者只需要用一个工厂即可
    - 增加一个产品族的方法只需要增加一个工厂
  - 缺点
    - 产品族增加一个产品时所有的工厂类都要修改

## 原型模式

用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。

- 通过原型对象克隆一个新的对象

- 角色
  - 抽象原型类：clone() 方法
  - 具体原型类：实现clone() 方法  返回复制得原型对象
  - 访问类：调用clone()   获取克隆对象

- 克隆
  - 浅克隆：引用类型仍然指向旧对象的地址（只克隆了引用）
  - 深克隆：引用类型指向了新的对象

- 使用场景
  - 对象的创建非常复杂，可以使用原型模式快捷的创建对象。
  - 性能和安全要求比较高。（可在clone()方法中使用反序列化获取新对象）

## 创建者模式

- 一个对象的创建很复杂，要设置各种属性的值
  - 若都在构造方法设置，会参数过多。
  - 若都用set，则代码长度过长
- 将对象的构造和装配解耦
- 角色
  - 构造者：一步步创建对象
  - 产品类：
- 

```java
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainboard("华硕")
                .memory("金士顿")
                .screen("三星")
                .build();
        System.out.println(phone);
    }
```

- 对比
  - 工厂模式VS建造者模式
    - 工厂方法模式注重的是整体对象的创建方式
    - 建造者模式注重的是部件一步步构建的过程
  - 抽象工厂模式VS建造者模式
    - 抽象工厂模式实现对产品家族的创建
    - 建造者模式通过组装零配件而产生产品

# ==结构型模式==

- 将类或对象按某种布局组成更大的结构。
  - 类结构型：采用继承机制来组织接口和类
  - 对象结构型：釆用组合或聚合来组合对象

- 分类
  - 代理模式
  - 适配器模式
  - 装饰者模式
  - 桥接模式
  - 外观模式
  - 组合模式
  - 享元模式

## 代理模式

- 访问者不适合直接引用 目标对象，通过代理对象间接访问
- 角色
  - 访问类
  - 代理类 ：实现业务接口，实现中包含了目标类的业务
  - 目标类：实现业务接口
  - 业务接口
- 分类
  - 静态代理
    - 实现定义好代理类的类文件。使用时直接new 创建
      - 缺点：若代理类很多，要定义很多类文件。
  - 动态代理
    - 运行时才创建代理类
    - JDK动态代理：Proxy.newProxyInstance()   
      - 代理类和目标类都实现了业务接口，通过反射动态创建代理类
    - CGLib动态代理
      - 没有业务接口时考虑，使用字节码技术生成代理类

- 场景
  - 明星-经纪人-粉丝
  - 火车票-售票处-乘客

## 适配器模式

- 将一个类的接口转换成客户希望的另外一个接口，使原本不能兼容的接口能够一起工作

- 角色
  - 目标（Target）接口：业务接口
  - 适配者（Adaptee）：已有的组件，没有实现了业务接口，不能兼容    （可以是类或者对象）
  - 适配器（Adapter）：转换器，实现了业务接口，在方法中调用已有组件的功能

- 例子
  - InputStreamReader实现了InputStream到Reader的适配

## 装饰者模式

- 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

- 角色
  - 组件接口：该接口的实现类都能够被装饰
  - 组件类：待装饰的类
  - 装饰品接口 ： 继承或实现组件接口，通过子类扩展装饰功能
  - 装饰品：给构建增加功能
- 优缺点
  - 优点
    - 通过组合而非继承的方式，动态地扩展一个对象的功能，在运行时可以选择不同的装饰器从而实现不同的功能
    - 避免了使用继承的方式扩展对象功能而带来的灵活性差、子类无限制扩张的问题
    - 具体组件类与具体装饰类可以独立变化，用户可以根据需要新增具体组件类跟装饰类，在使用时在对其进行组合，原有代码无须改变，符合"开闭原则"
  - 缺点
    - 比继承更加灵活机动的特性，也同时意味着更加多的复杂性
    - 致设计中出现许多小类 (I/O 类中就是这样)，如果过度使用，会使程序变得很复杂。

- 例子
  - JavaIO中
    - BufferedWriter 对 Writer增加了缓冲区

- 装饰者和代理模式
  - 相同点：
    * 都要实现与目标类相同的业务接口
    * 在两个类中都要声明目标对象
    * 都可以在不修改目标类的前提下增强目标方法
  - 不同点：
    * 目的
      * 装饰者是为了增强目标对象
      * 静态代理是为了保护和隐藏目标对象
    * 获取目标对象方式
      * 装饰者是由外界传递进来，可以通过构造方法传递
      * 静态代理是在代理类内部创建，以此来隐藏目标对象



## 桥接模式

- 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
  - 即当一个类有两个或更多维度要扩展时，应使用组合而不是继承
  - 若用继承，则增加一个维度，则会增加很多子类，扩展不灵活
- 装饰者和桥接模式
  - 装饰者
    - 不改变原有对象增加新的功能（外部增加
  - 桥接
    - 维度属于原有对象本身（内部扩展





## 外观模式

- 多个复杂的子系统实现一个一致的接口，外部程序不用关心内部子系统的具体细节
  - 符合迪米特法则，通过接口（第三方）访问
- 角色
  - 外观（Facade）角色：统一的接口
  - 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。

- 优缺点
  - 优点
    - 降低调用者和子系统耦合度，调用者也不用针对不同的子系统增加不
    - 增加易用性，对客户屏蔽了子系统组件，减少了客户处理的对象数目
  - 缺点
    - 不符合开闭原则
      - 修改一个子系统，则要修改外观接口，导致 所有子系统都要改变



## 组合模式

- （部分整体模式：是用于把一组相似的对象当作一个单一的对象
  - 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

- 角色
  - 抽象节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。      （调用子节点会抛异常
  - 中间节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。  （重写使其拿到子节点
  - 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。   （不重写
- 例子
  - 树形的文件结构，这些节点分为中间节点和叶子节点，客户希望能够一致对待这两种节点

## 享元模式

- 共享已经存在的对象
  - 大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。
- 享元
  - 内部状态，即不会随着环境的改变而改变的可共享部分。
  - 外部状态，指随环境改变而改变的不可以共享的部分

- 角色
  - 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
  - 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
  - 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
  - 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

- 优缺点
  - 优点
    - 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能
    - 享元模式中的外部状态相对独立，且不影响内部状态
  - 缺点
    - 分离内部状态和外部状态，使程序逻辑复杂
- 总结
  - 大概就是共享相同的部分（单例）
  - 返回单例的不同状态（不同享部分
- 例子
  - 俄罗斯方块
    - 方块本身是享元（单例可共享
    - 不同的对象使用享元，只是方向不同
  - Integer
    - `Integer` 默认先创建并缓存 `-128 ~ 127` 之间数的 `Integer` 对象(共享了），当调用 `valueOf` 时如果参数在 `-128 ~ 127` 之间则计算下标并从缓存中返回，否则创建一个新的 `Integer` 对象。

# ==行为型模式==

- 类和对象的行为。也就是流程控制
- 描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务
- 分类

  - 模板方法模式
  - 策略模式
  - 命令模式
  - 职责链模式
  - 状态模式
  - 观察者模式
  - 中介者模式
  - 迭代器模式
  - 访问者模式
  - 备忘录模式
  - 解释器模式

## 模板方法模式

- 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
- 

- 结构
  - 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

    - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。

    - 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：

      - 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。

      - 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。

      - 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。

      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

  - 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。

- 优缺点

  - 优点
    - 提高代码复用性
      - 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。
    - 实现了反向控制
      - 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。
  - 缺点
    - 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
    - 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。

- 例子
  
  - InputStream定义好了read()方法并要求子类必须重写



## 策略模式

- 定义好一系列策略算法，可以互相替换，客户可以选择不同的策略

- 角色
  - 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
  - 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。
  - 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

- 优缺点
  - 优点
    - 策略类之间可以自由切换
      - 由于策略类都实现同一个接口，所以使它们之间可以自由切换
    - 易于扩展
      - 增加一个新的策略只需要添加一个具体的策略类
  - 缺点
    - 客户端要知道所有的策略类，才好决定使用哪一个策略类。
    - 策略模式将造成产生很多策略类

- 例子
  - Arrays.sort()    根据传入不同比较策略Comparator 来排序



## 命令模式

- 一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。

- 角色
  - 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。
  - 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
  - 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
  - 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正
  - 触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。

- 优缺点
  - 优点
    - 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦
    - 增加或删除命令非常方便
  - 缺点
    - 系统结构更加复杂

- 例子
  - 线程
    - Runnable命令的角色，Thread调用者，start触发命令

## 责任链模式

- 请求的处理者，处理完后，将请求传递给下一个处理者。形成一条传递链
- 角色
  - 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
  - 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
  - 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

- 优缺点
  - 优点
    - 增强了系统的可扩展性，可以根据需要增加新的请求处理类
    - 责任分担，一个处理者提供一种处理方式。符合单一职责原则
  - 缺点
    - 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理
    - 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。

- 例子
  - 在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用



## 状态模式

- 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，不同状态有不同反应

- 角色
  - 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
  - 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
  - 具体状态（Concrete  State）角色：实现抽象状态所对应的行为。

- 优缺点
  - 优点
    - 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
    - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
  - 缺点
    - 状态模式的使用必然会增加系统类和对象的个数。 
    - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。

- 使用场景
  - 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。
  - 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。



## 观察者（发布订阅）模式

- 又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

- 角色
  - Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
  - ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
  - Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
  - ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

- 优缺点
  - 优点	
    - 降低了目标与观察者之间的耦合关系
    - 很好满足广播机制
  - 缺点
    - 订阅者过多时，订阅者都收到消息会很耗时



## 中介者模式

- 一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
  - 星形，多个对象

- 角色
  - 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
  - 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
  - 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
  - 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

- 优缺点
  - 优点
    - 松散耦合，各对象的调用只需要通过中介对象即可
    - 集中控制交,中介对象统筹对象的调用
    - 一对多关联转变为一对一的关联,都与中介对象产生联系
  - 缺点
    - 当对象过多时，中介对象的实现会很复杂



## 迭代器模式

- 提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 

- 角色
  - 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。
  - 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
  - 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。
  - 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。
- 优缺点
  - 优点
    - 不用暴露集合的内部表示就可以遍历，简单易用
    - 引入了抽象层，很方便更换迭代方式
  - 缺点
    - 增加系统复杂度。。

- 例子
  - Java的容器ArrayList，HashMap等



## 访问者模式

- 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。

- 角色
  - 抽象访问者（Visitor）角色：定义了对每一个元素`（Element）`访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。
  - 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。
  - 抽象元素（Element）角色：定义了一个接受访问者的方法（`accept`），其意义是指，每一个元素都要可以被访问者访问。
  - 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
  - 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（`Element`），并且可以迭代这些元素，供访问者访问。

- 优缺点
  - 优点
    - 耦合度低
      - 把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。
    - 扩展性好
      - 在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
    - 复用性好
      - 通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
    - 分离无关行为
      - 通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。
  - 缺点
    - 对象结构变化很困难
      - 在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
    - 违反了依赖倒置原则
      - 访问者模式依赖了具体类，而没有依赖抽象类。



- 应用场景
  - 适用于数据结构相对稳定算法又易变化的系统

## 备忘录模式



- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
- 角色
  - 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
  - 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
  - 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

- 分类
  - 白箱备忘录
    - 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开
  - 黑箱备忘录
    - 备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将**备忘录类**设计成**发起人类**的内部成员类
- 例子
  - 游戏存档
  - Ctrl+Z回档

- 优缺点
  - 优点
    - 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
    - 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
    - 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则
  - 缺点
    - 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源

## 解释器模式

- 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子
- 角色
  - 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。

  - 终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
  - 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
  - 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
  - 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。

- 优缺点

  - 优点

    - 易于改变和扩展文法。
      - 由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。
    - 实现文法较为容易。
      - 在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。
    - 增加新的解释表达式较为方便。
      - 如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 "开闭原则"

  - 缺点

    - 对于复杂文法难以维护。
      - 在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。

    * 执行效率较低。
      * 由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。

    