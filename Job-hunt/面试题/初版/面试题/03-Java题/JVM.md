# ==内存结构==

## JVM

- 定义

  Java Virtual Machine，JAVA程序的**运行环境**（JAVA二进制字节码的运行环境）

- 好处
  - 一次编写，到处运行
  - 自动内存管理，垃圾回收机制
  - 数组下标越界检查

- 比较

  JVM JRE JDK的区别

  [![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png)

## JVM 指令

* jps
  * 显式虚拟机进程
* jstat
  * 监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
* jmap
  * 查看堆快照
* jhat
  * 分析堆快照
* jstack
  * 查看线程快照
* jconsole
  - 可视化的管理控制台

## JMM

- **Java 内存模型**（**JMM**）
  - 是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确指定了一组排序规则，来保证线程间的可见性。
  - 这一组规则被称为 **Happens-Before**
    - 要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 **Happens-Before 关系**

- **Happens-Before**
  - **单线程规则**：一个线程中的每个动作都 happens-before 该线程中后续的每个动作
  - **监视器锁定规则**：监听器的**解锁**动作 happens-before 后续对这个监听器的**锁定**动作
  - **volatile 变量规则**：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作
  - **线程 start 规则**：线程 **start()** 方法的执行 happens-before 一个启动线程内的任意动作
  - **线程 join 规则**：一个线程内的所有动作 happens-before 任意其他线程在该线程 **join()** 成功返回之前
  - **传递性**：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C

## 内存模型

- **一方法区，一堆，两栈，一程序计数器,一直接内存**

- 程序计数器（线程私有）
  - 用于保存线程下一条所要执行的指令的地址

- 虚拟机栈（线程私有）
  - 每个方法在执行的时候就会创建一个栈帧
  - 用于存储局部变量表(基本数据类型和对象的引用)、操作数、动态链接和方法返回等信息
  - 栈由多个栈帧组成，内存不够时抛出stackOverflowError 异常
- 本地方法栈（线程私有
  - 保存的是native方法的，来与操作系统底层交互
- 堆（线程共享
  - 对象在堆上分配内存，涉及垃圾回收
- 方法区（线程共享
  - 存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据

- 直接内存（不在JVM）
  - 属于操作系统，常见于NIO操作时，**用于数据缓冲区**
  - 分配回收成本较高，但读写性能高
  - 不受JVM内存回收管理

## 对象及其引用

- 对象
  - 无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
- 引用
  - 引用类型的引用和基本类型的值存储的地方相同。
  - 当变量为**局部变量**时，引用类型的引用和基本类型的值存储在**栈内存**中。
  - 当变量为**成员变量**时，引用类型的引用和基本类型的值存储在**堆内存**中。
  - 当变量为**静态变量**时，引用类型的引用和基本类型的值存储在**方法区**中。

## heap 和stack 

- 堆和栈

  - 栈保存局部变量等线程信息
  - 对象在堆上分配内存，涉及垃圾回收

- 申请方式
  - stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间
  - heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟

- 申请后系统的响应
  - stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
  - heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

- 申请大小的限
  - stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
  - heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。

- 申请效率的比较
  - stack：由系统自动分配，速度较快。但程序员是无法控制的。
  - heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

- heap和stack中的存储内容

  - stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

    当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
    
  - heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

## OOM

- 除了程序计数器，其他内存区域都有 OOM（内存溢出） 的风险。
  - 栈
    - 一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM
  - 堆
    - 溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；
    - GC 之后无法在堆中申请内存创建对象就会报错；
  - 方法区 
    - 经常会遇到的是动态生成大量的类、jsp 等；
  - 直接内存 
    - 涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。

- 排查 OOM 的方法：
  - 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；
  - 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；
  - 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

##  常量池

* **Class文件常量池**
  * class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。
  * 字节码文件
* **运行时常量池**：
  * 运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。
  * String.intern()运行时产生
* **全局字符串常量池**：
  * 字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。 
  * StringTable缓存字符串
* **基本类型包装类对象常量池**：
  * java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。
  * 缓存了【-129-127】之间的数据

# ==GC==

## 判断对象可回收

- 引用计数法

  - 某对象没有被引用时可回收

  - 缺点：无法回收循环引用的对象

- 可达性分析算法
  - JVM中的垃圾回收器通过**可达性分析**来探索所有存活的对象
  - 扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果**找不到，则表示可以回收**
  - 可以作为GC Root的对象（不认为需要回收的对象
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象。　
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI（即一般说的Native方法）引用的对象

## 四种引用

[![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png)

- 强引用
  - 如new出来的对象
  - 只有GC Root**都不引用**该对象时，才会回收**强引用**对象
- 软引用
  - 当GC Root指向软引用对象时，在**内存不足时**，会**回收软引用所引用的对象**
- 弱引用
  - 在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象
- 虚引用
  - 虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法
    - 主要用来跟踪对象被垃圾回收的活动

## 垃圾回收算法

- 标记-清除

  - 先标记可回收对象的内存空间，后清除
  - 并不是将内存空间的字节清0，而是记录下地址，下次分配时直接覆盖

  - 不足
    - 容易产生内存碎片

- 标记-整理

  - 先标记，后整理到连续的内存空间。两个幸存区From和To，解决内存碎片化
  - 缺点：需要额外的空间，且复制时消耗更多时间

  


## 分代回收

[![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png)

- 分代是针对不同生命周期的对象作不同的处理，生命周期长的减少GC次数
- 流程
  - 新创建的对象
    - 都被放在了新生代的伊甸园
  - 伊甸园空间不足
    - 进行Minor GC : 将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存区
    - 存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中
  - 新生代、老年代空间不足
    - 会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不再使用的对象并回收（比较费时）
- 其他
  - 大对象处理
    - 直接晋升老年代

## 垃圾回收器

- 概念
  - **并行收集**：指多条垃圾收集线程并行工作，用户线程阻塞
  - **并发收集**：指用户线程与垃圾收集线程同时工作，可交替执行
  - **吞吐量**：吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )

- 串行GC处理器
  - 特点
    - 只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞态
  - Serial 收集器
    - 最基本的、发展历史最悠久的收集器
    - 特点：**单线程、简单高效（与其他收集器的单线程相比），采用**复制算法**。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）
  - ParNew 收集器
    - ParNew收集器其实就是Serial收集器的多线程版本
    - **特点**：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题
  - Serial Old 收集器
    - Serial Old是Serial收集器的老年代版本
    - **特点**：同样是单线程收集器，采用**标记-整理算法**

- 吞吐量优先
  - 特点
    - 多线程
    - 堆内存较大，多核CPU
    - 单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短
    - **JDK1.8默认使用**的垃圾回收器

  - Parallel Scavenge 收集器
    - 与吞吐量关系密切，故也称为吞吐量优先收集器
    - **特点**：属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）
  - **Parallel Old 收集器**
    - Parallel Scavenge收集器的老年代版本
    - **特点**：多线程，采用**标记-整理算法**（老年代没有幸存区）

- 响应时间优先

  - 特点
    - 多线程
    - 堆内存较大，多核CPU
    - 尽可能让单次STW时间变短（尽量不影响其他线程运行）

  - CMS 收集器
    - Concurrent Mark Sweep，一种以获取**最短回收停顿时间**为目标的**老年代**收集器
    - **特点**：基于**标记-清除算法**实现。并发收集、低停顿，但是会产生内存碎片
    - **应用场景**：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务
    - **CMS收集器的运行过程分为下列4步：**
      - **初始标记**：标记GC Roots能直接到的对象。速度很快但是**仍存在Stop The World问题**
      - *并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行**
      - 重新标记**：为了**修正并发标记期间**因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题**
      - 并发清除**：对标记的对象进行清除回收

- 吞吐量和响应时间兼顾
  - G1
    - Garbage First，JDK 9以后默认使用，而且替代了CMS 收集器
  - 特点
    - 同时注重吞吐量和低延迟（响应时间）
    - 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域
    - 整体上是**标记-整理**算法，两个区域之间是**复制**算法

- **分区算法region**

  分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间

- Full GC

  G1在老年代内存不足时（老年代所占内存超过阈值）

  - 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
  - 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

## 三色标记

- 标记 - 清除 法，
  - 这个标记会根据这个对象是否可达（GC Roots）来进行一个标记设置，GC 回收的时候就会根据这个标记进行清除。
  - 标记 - 清除 法最大的问题就是在清除的-时候需要 STW 这就导致了 GC 的效率就比较低。

- 三色标记
  - 三色标记最大的好处就是可以与业务线程并发执行，从而显著的提升标记的效率，三色 对应黑、白、灰三种颜色，每种颜色都代表着不同的意思
  - 三色
    - **黑色**：根对象或它所有的子对象都以及被扫描过。
    -  **灰色**：本身被扫描但是它的子对象还没被扫描完。
    -  **白色**：没有被扫描过的对象，如果扫描标记完成后还是白色的说明这个对象是垃圾。

- 并发带来问题
  - 因为在标记的时候业务线程还在继续运行，那么就会存在当 GC 其中一条线程以及完成标记扫描后与其他一条线程未被扫描完成后的对象发生了引用的改变。
  - 处理 
    - CMS 是重新扫描所有的对象
    -  G1 则是以修改的引用作为根进行扫描   （效率更高

## 跨代引用

- 跨代引用 一般指的是老年代的对象中引用了新生代的对象，如果新生代发生 Young GC 的时候就需要扫从老年代到新生代的所有引用，这样的扫描就比较消耗性能，所以就存在了Card Table（卡表） 和 Rset（记忆集）。

- CardTable
  - 类似于一个数组，元素对应了每个内存区域。
  - 发生跨代引用则标记为1，并放一个RSet

- RSet
  - 存放某个内存区域的跨代引用，GC时扫描这里就行了



## GC 调优

- 调优领域
  - 内存
  - 锁竞争
  - CPU占用
  - IO
  - GC

- 选择合适的GC
  - CMS G1 ZGC
  - ParallelGC
  - Zing

- 最快的GC是不发生GC
  - 首先排除减少因为自身编写的代码而引发的内存问题
  - 查看Full GC前后的内存占用，考虑以下几个问题
    - 数据是不是太多？
    - 数据表示是否太臃肿
      - 对象图
      - 对象大小
    - 是否存在内存泄漏

- 新生代调优
  - 新生代的特点
    - 所有的new操作分配内存都是非常廉价的
      - TLAB
    - 死亡对象回收零代价
    - 大部分对象用过即死（朝生夕死）
    - MInor GC 所用时间远小于Full GC
  - 新生代内存越大越好么？
    - 不是
      - 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
      - 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长
    - 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜

- 幸存区调优
  - 幸存区需要能够保存 **当前活跃对象**+**需要晋升的对象**
  - 晋升阈值配置得当，让长时间存活的对象尽快晋升

# ==类加载==

## 字节码文件结构

- 魔数
  - 可以标识文件格式的常量数值或者文本值。
  - 标识文件的格式使用魔数，而不是扩展名。主要是基于安全方面的考虑，因为文件的扩展名是可以随意修改的。

- 版本
  
- java版本
  
- 常量池

  - 常量池里面主要存放两个大类：字面量（Literal）和符号引用（Symbolic References）。
    - **字面量**是常量里具体的值（包括 final 修饰的）。
    -  **符号引用**是类的权全限定名、字段的名称和描述符等。

- 访问标志

  - 用于识别一些类或者接口层次的访问信息，接口，访问权限等

- ##### 父类索引

  - 确认类的继承关系

- ##### 字段表集合

  - 类变量，实例变量等

## 语法糖

- 属于编译期的优化
- 所谓的 **语法糖** ，其实就是指 java 编译器把 *.java 源码编译为 \*.class 字节码的过程中，**自动生成**和**转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利

- 默认构造函数
  - 若没有显式提供，则提供一个默认的无参构造函数

- 自动拆装箱
  - 基本类型和其包装类型的相互转换过程，称为拆装箱
  - 编译期完成，运行时性能不会下降

- 泛型集合取值
  - 泛型也是在 JDK 5 开始加入的特性，但 java 在**编译泛型代码后**会执行 **泛型擦除** 的动作，即泛型信息在编译为字节码之后就**丢失**了，实际的类型都当做了 **Object** 类型来处理：

- 可变参数
  - 可变参数 **String…** args 其实是一个 **String[]** args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：

- foreach
  - 遍历数组，不用写i
  - 集合要使用foreach，需要该集合类实现了**Iterable接口**，因为集合的遍历需要用到**迭代器Iterator**

- switch
  - 可以是字符串
  - 可以是枚举

- 枚举类
  - 其实是一个类，编译器帮转化为正常的结构

- 匿名内部类

## 类加载阶段

- 加载
  - 将类的字节码载入方法区
  - 如果这个类还有父类没有加载，**先加载父类**
  - 加载和链接可能是**交替运行**的

- 链接
  - 验证
    - 验证类是否符合 JVM规范，安全性检查
  - 准备
    - 为 static 变量分配空间，设置默认值
  - 解析
    - 将常量池中的符号引用解析为直接引用

- 初始化
  - 初始化阶段就是**执行类构造器clinit()方法的过程**，虚拟机会保证这个类的构造方法的线程安全
  - clinit()方法是由编译器自动收集类中的所有类变量的**赋值动作和静态语句块**（static{}块）中的语句合并产生的

## 类加载器

- 简介
  - JVM外的程序，通过一个类的全限定名来获取描述该类的二进制字节流，放在外部以便让应用程序自己决定如何去获取所需的类
  - 每个类加载器都有自己的命名空间，同一类加载器下的同一字节码文件的类才相等
- 分类
  - 启动类加载器（BootStrapClassLoader）
    - 用来加载java核心类库，无法被java程序直接引用；
  - 扩展类加载器（Extension ClassLoader）
    - 用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；
  - 系统类加载器（AppClassLoader）
    - 它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；
  - 自定义类加载器
    - 由java语言实现，继承自ClassLoader

## 双亲委派

- 当一个类加载器收到一个类加载的请求
  - 他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载
  - 只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；
- 好处
  - 为了防止内存中出现多个相同的字节码
  - 因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性、安全性。
- 破坏双亲委派模式
  - 自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法
  - Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器
  - 热部署

## 运行期优化

- 即时编译器（JIT）与解释器的区别
  - 解释器
    - 将字节码**解释**为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
    - 是将字节码解释为针对所有平台都通用的机器码
  - 即时编译器（缓存）
    - 将一些字节码**编译**为机器码，**并存入 Code Cache**，下次遇到相同的代码，直接执行，无需再编译
    - 根据平台类型，生成平台特定的机器码

- 逃逸优化
  - 逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术
  - 逃逸：对象的作用方法超出当前线程
  - 没有逃逸时
    - 锁消除
      - 去除没有必要的锁
    - 标量替换
      - 标量：不可再分解的量，如基础类型，对象的引用。聚合量：可进一步分解的量，如对象
      - 若一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能
