## 剑指 Offer 14- I. 剪绳子

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

- dp

  ```java
  class Solution {
      public int cuttingRope(int n) {
          int []dp=new int[n+1];
          dp[1]=1;
  
          for(int i=2;i<=n;i++){
              int temp=i-1;
              for(int j=1;j<i;j++){
                  temp=Math.max(temp,Math.max(j*(i-j),j*dp[i-j]));
              }   
              dp[i]=temp;
          }
          return dp[n];
      }
  }
  ```




## 剑指 Offer II 112. 最长递增路径



- 给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

  对于每个单元格，你可以往上，下，左，右四个方向移动。 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）

- 记忆化搜索

  ```java
  class Solution {
      //记忆化是dp的思想吗，搜索是dfs的思想
      //用到dfs思想有可能是反着填写结果，这个要注意
      private int [][]dirs=new int[][]{{0,-1},{0,1},{-1,0},{1,0}};
      public int longestIncreasingPath(int[][] matrix) {  
          int[][]dp=new int[matrix.length][matrix[0].length];
          int ans=1;
          for(int i=0;i<matrix.length;i++){
              for(int j=0;j<matrix[0].length;j++){
                  ans=Math.max(ans,dfs(matrix,dp,i,j));
              }
          }
          return ans;
      }
      private int dfs(int [][]matrix,int [][]dp,int x,int y){
          if(dp[x][y]!=0){
              return dp[x][y];
          }
          dp[x][y]=1;
          for(int []dir:dirs){
              int newX=x+dir[0];
              int newY=y+dir[1];
              if(newX>=0 && newX<matrix.length && newY>=0 && newY<matrix[0].length 
                &&  matrix[newX][newY]>matrix[x][y]){
                  dp[x][y]=Math.max(dp[x][y],dfs(matrix,dp,newX,newY)+1);
              }
          }
          return dp[x][y];
      }
  }
  ```

  

## 剑指 Offer 04. 二维数组中的查找

难度中等924

在一个 n * m 的二维数组中，每一行都按照从左到右 **非递减** 的顺序排序，每一列都按照从上到下 **非递减** 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`

- 二分查找

  - nlogn
  - 不好处理，则对每一行就行二分查找

  ```java
  class Solution {
  
      public boolean findNumberIn2DArray(int[][] matrix, int target) {
  
          for(int nums[]:matrix){
              int lx=0;
              int rx=nums.length-1;
              while(lx<=rx){
                  int mid=lx+(rx-lx)/2;
                  if(nums[mid]==target){
                      return true;
                  }else if(nums[mid]<target){
                      lx=mid+1;
                  }else{
                      rx=mid-1;
                  }
              }
          }
          return false;
      }
  }
  ```

- Z形查找

  - n+m
  - 从右上角出发，若小于，则x++，大于则y--

  ```java
  class Solution {
      public boolean findNumberIn2DArray(int[][] matrix, int target) {
          if(matrix.length==0 || matrix[0].length==0){
              return false;
          }
          int x=0;
          int y=matrix[0].length-1;
          while(x<matrix.length && y>=0){
              if(matrix[x][y]==target){
                  return true;
              }else if(matrix[x][y]<target){
                  x++;
              }else{
                  y--;
              }
          }
          return false;
      }
  }
  ```

  

## 剑指 Offer 07. 重建二叉树

难度中等1036

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**示例 2:**

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

- 3

  ```java
  class Solution {
      HashMap<Integer,Integer>map=new HashMap<>();
      int[]pre;
      int []in;
      //根据前序找新的根节点，根据根节点在中序中的位置找左右子树的位置
      public TreeNode buildTree(int[] preorder, int[] inorder) {
         
          for(int i=0;i<inorder.length;i++){
              map.put(inorder[i],i);
          }
          pre=preorder;
          in=inorder;
          return build(0,0,in.length-1);
      }
  
      // r 根节点在pre中的下标，lx，ly根据r在in划分的左子树
      private TreeNode build(int root,int l,int r){
          if(l>r){
              return null;
          }
          TreeNode rootNode=new TreeNode(pre[root]);
          int i=map.get(pre[root]); //当前root在in中的位置
          //因为i是中序中的位置，所以不能用来找新的root
          rootNode.left=build(root+1,l,i-1); //左子树的根节点是前序遍历root加一
          rootNode.right=build(root+i-l+1,i+1,r);//右子树的根节点是前序遍历中，root+左子树的数量
          return rootNode;
      }
  }
  ```


## 131. 分割回文串(dp+dfs)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

- 稍微注意下初始化问题

  ```java
  class Solution {
      int n;
      boolean [][]dp;
      List<List<String>> ans=new ArrayList<>();
      List<String>list=new ArrayList<>();
      public List<List<String>> partition(String s) {
          n=s.length();
          dp=new boolean[n][n];
          //dp[i+1][j-1]可能还没初始化，所以先把能求的求出来
          //单个
          for(int i=0;i<n;i++){
              dp[i][i]=true;
          }
          //相邻
          for(int i=0;i<n-1;i++){
              dp[i][i+1]=s.charAt(i)==s.charAt(i+1);
          }
  
          //i还是要从后面算起，j从前面算起，防止dp[i+1][j-1]没有初始化
          for(int i=n-3;i>=0;i--){
              for(int j=i+2;j<n;j++){
                  dp[i][j]=s.charAt(i)==s.charAt(j)&&dp[i+1][j-1];
              }
          }
          dfs(0,s);
          return ans;
      }
  	//正常dfs
      private void dfs(int x,String s){
          if(x==n){
              ans.add(new ArrayList<>(list));
          }
          for(int i=x;i<n;i++){
              if(dp[x][i]){
                  list.add(s.substring(x,i+1));
                  dfs(i+1,s);
                  list.remove(list.size()-1);
              }
          }
      }
  }
  ```

  

## 298. 二叉树最长连续序列（dfs）

难度中等111

给你一棵指定的二叉树的根节点 `root` ，请你计算其中 **最长连续序列路径** 的长度。

**最长连续序列路径** 是依次递增 1 的路径。该路径，可以是从某个初始节点到树中任意节点，通过「父 - 子」关系连接而产生的任意路径。且必须从父节点到子节点，反过来是不可以的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg)

```
输入：root = [1,null,3,2,4,null,null,null,5]
输出：3
解释：当中，最长连续序列是 3-4-5 ，所以返回结果为 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg)

```
输入：root = [2,null,3,2,null,1]
输出：2
解释：当中，最长连续序列是 2-3 。注意，不是 3-2-1，所以返回 2 。
```

- 直接算

  - 结束时取最大值

  ```java
  class Solution {
      int ans=1;
      public int longestConsecutive(TreeNode root) {
          dfs(root,root.left,1);
          dfs(root,root.right,1);
          return ans;
      }
  
      private void dfs(TreeNode pre,TreeNode node,int len){
          if(node==null){
              ans=Math.max(ans,len);
              return;
          }
          if(node.val==pre.val+1){
              dfs(node,node.left,len+1);
              dfs(node,node.right,len+1);
          }else{
              ans=Math.max(ans,len);
              dfs(node,node.left,1);
              dfs(node,node.right,1);
          }
      }
  }
  ```

  

## 464. 我能赢吗(状压+记忆化dfs)

在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过** 100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。

 

**示例 1：**

```
输入：maxChoosableInteger = 10, desiredTotal = 11
输出：false
解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```

**示例 2:**

```
输入：maxChoosableInteger = 10, desiredTotal = 0
输出：true
```

**示例 3:**

```
输入：maxChoosableInteger = 10, desiredTotal = 1
输出：true
```

- 就是这样

  - 只有一个变化状态，比较好考虑状压
  - 再配合记忆化搜索

  ```java
  class Solution {
      //状态压缩+记忆化搜索
      //保存计算好的状态,以及该状态的结果
      HashMap<Integer,Boolean>map=new HashMap<>();
      int n;
      int s;
      public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
          n=maxChoosableInteger;
          s=desiredTotal;
          //谁都赢不了
          if((1+n)*n/2<s){
              return false;
          }
          return dfs(0,0);
      }
      private boolean dfs(int state,int sum){
          if(!map.containsKey(state)){
              boolean res=false;
              for(int i=0;i<n;i++){
                  //当前状态没有计算
                  if(((state>>i)&1)==0){  //位运算优先级很低，要多加一个()
                      if(i+1+sum>=s){
                          res=true;
                          break;
                      }
                      if(!dfs(state | (1<<i),sum+i+1)){
                          res=true;
                          break;
                      }
                  }
  
              }
              map.put(state,res);
          }
          return map.get(state);
      }
  }
  ```

  

## 526. 优美的排列（dfs）

难度中等345

假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 `perm`（**下标从 1 开始**），只要满足下述条件 **之一** ，该数组就是一个 **优美的排列** ：

- `perm[i]` 能够被 `i` 整除
- `i` 能够被 `perm[i]` 整除

给你一个整数 `n` ，返回可以构造的 **优美排列** 的 **数量** 。

 

**示例 1：**

```
输入：n = 2
输出：2
解释：
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
```

**示例 2：**

```
输入：n = 1
输出：1
```

- dfs

  ```java
  class Solution {
      int n;
      boolean v[];
      int ans=0;
      //两个变化的量，不好用状态压缩
      public int countArrangement(int n) {
          this.n=n;
          v=new boolean[n];
          dfs(1);
          return ans;
      }
  
      private void dfs(int x){
          if(x==n+1){
              ans++;
              return;
          }        
          for(int j=0;j<n;j++){
              if(!v[j]&& ((j+1)%x==0 || x%(j+1)==0)){
                  v[j]=true;
                  dfs(x+1);
                  v[j]=false;
              }
          }
      }
  }
  ```

## 718. 最长重复子数组（dp）

难度中等904

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

**示例 2：**

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

- dp

  ```java
  class Solution {
      public int findLength(int[] nums1, int[] nums2) {
          int m=nums1.length;
          int n=nums2.length;
          int[][]dp=new int[m+1][n+1];
          int ans=0;
          for(int i=0;i<m;i++){
              for(int j=0;j<n;j++){
                  dp[i+1][j+1]=nums1[i]==nums2[j]?dp[i][j]+1:0;
                  ans=Math.max(ans,dp[i+1][j+1]);
              }
          }
          return ans;
      }
  }
  ```

- 滑动窗口

## 1062. 最长重复子串(O（n2)的后缀数组）

给定字符串 `S`，找出最长重复子串的长度。如果不存在重复子串就返回 `0`。

**示例 1：**

```
输入："abcd"
输出：0
解释：没有重复子串。
```

**示例 2：**

```
输入："abbaba"
输出：2
解释：最长的重复子串为 "ab" 和 "ba"，每个出现 2 次。
```

**示例 3：**

```
输入："aabcaabdaab"
输出：3
解释：最长的重复子串为 "aab"，出现 3 次。
```

**示例 4：**

```
输入："aaaaa"
输出：4
解释：最长的重复子串为 "aaaa"，出现 2 次。
```

 

**提示：**

1. 字符串 `S` 仅包含从 `'a'` 到 `'z'` 的小写英文字母。
2. `1 <= S.length <= 1500`

- 不能够和上一题一样用dp，因为可能出现自己跟自己比较的情况，这不算重复

- 这道题的s长度比较小，可以用最简单版的后缀数组比较

  - 若是1044的长度，则要最优版的(nlogn)

  ```java
  class Solution {
      public int longestRepeatingSubstring(String s) {
          int n=s.length();
          int ans=0;
          String []strs=new String[n];
          for(int i=n-1;i>=0;i--){
              strs[i]=s.substring(i);
          }
          Arrays.sort(strs);
          for(int i=0;i<n-1;i++){
              int c=0;
              int len=Math.min(strs[i].length(),strs[i+1].length());
              for(int j=0;j<len;j++){
                  if(strs[i].charAt(j)==strs[i+1].charAt(j)){
                      c++;
                  }else{
                      break;
                  }
              }
              ans=Math.max(c,ans);
          }
          return ans;
      }
  }
  ```

  

## 208. 实现 Trie (前缀树 或者 字典树)

**Trie（发音类似 "try"）或者说 **前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

- 直接抄答案（本题都是小写字母）

  - 还是很好理解
  - 主要是递归建树

  ```java
  class Trie {
  
      //存放下一个指针
      private Trie []children;//某下标处i不为null则有以(char)('a'+i)字符开头的下一个节点
      //是否为叶子节点
      private boolean isEnd;
      public Trie() {
          children=new Trie[26];
          isEnd=false;
      }
      
      public void insert(String word) {
          Trie node=this;
          for(int i=0;i<word.length();i++){
              char c=word.charAt(i);
              int x=c-'a';
              if(node.children[x]==null){
                  node.children[x]=new Trie();  //当前递归节点
              }
              node=node.children[x]; //递归建树
          }
          node.isEnd=true;
      }
      
      //包含完整的字符串
      public boolean search(String word) {
          Trie node=searchPrefix(word);
          return node!=null && node.isEnd;
      }
      
      public boolean startsWith(String prefix) {
          return searchPrefix(prefix)!=null;
      }
  
      //只是前缀
      private Trie searchPrefix(String prefix){
          Trie node=this;
          for(int i=0;i<prefix.length();i++){
              char c=prefix.charAt(i);
              int x=c-'a';
              if(node.children[x]==null){
                  return null;
              }
              node=node.children[x];
          }
          return node;
      }
  }
  ```

## 139. 单词拆分（j<i的dp）

难度中等2062

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

- 逆过来dp，在已经计算好的i基础上再dp j

  ```java
  class Solution {
      //逆过来的dp
      public boolean wordBreak(String s, List<String> wordDict) {
          HashSet<String>set=new HashSet<>(wordDict);
          int n=s.length();
          boolean []dp=new boolean[n+1];
          dp[0]=true; //0是""
          for(int i=1;i<=n;i++){   //以i为结尾
              for(int j=0;j<i;j++){
                  //跟前面j相连
                  if(dp[j] && set.contains(s.substring(j,i))){
                      dp[i]=true;
                      break;
                  }
              }
          }
  
          return dp[n];
      }
  }
  ```

## 140. 单词拆分 II(dp+dfs)

难度困难682

给定一个字符串 `s` 和一个字符串字典 `wordDict` ，在字符串 `s` 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。

**注意：**词典中的同一个单词可能在分段中被重复使用多次。

 

**示例 1：**

```
输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]
输出:["cats and dog","cat sand dog"]
```

- 先dp求出所有的可能，再dfs找路径

  - dp相当于记忆化
  - 因为直接dfs有点不好处理

  ```java
  class Solution {
      List<String> ans=new LinkedList<>();
      int n;
      boolean []dp;
      HashSet<String> set;
      List<String> list=new LinkedList<>();
      
      public List<String> wordBreak(String s, List<String> wordDict) {
          n=s.length();
          dp=new boolean[n+1];
          set=new HashSet<>(wordDict);
          dp[0]=true;
          for(int i=1;i<=n;i++){
              for(int j=0;j<i;j++){
                  if(dp[j] && set.contains(s.substring(j,i))){
                      dp[i]=true;
                      break;
                  }
              }
          }
          dfs(0,s);
          return ans;
  
      }
      private void dfs(int x,String s){
          if(x==n){
              StringBuilder sb=new StringBuilder();
              for(String str:list){
                  sb.append(" "+str);
              }
              ans.add(sb.deleteCharAt(0).toString());
              return;
          }
  		//对后续dp数组进行dfs
          for(int i=x+1;i<=n;i++){
              if(dp[i] && set.contains(s.substring(x,i))){
                  list.add(s.substring(x,i));
                  dfs(i,s);
                  list.remove(list.size()-1);
              }
          }
      }
  }
  ```

  

## 238. 除自身以外数组的乘积（前缀积+后缀积）

难度中等1410

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请**不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

- 答案数组不算额外空间，要想O(1)，那么就在答案数组上修改

  - 不必局限于前缀和就是元素之和，也可以是积，或者其他某种状态的叠加

  ```java
  class Solution {
      public int[] productExceptSelf(int[] nums) {
          int n=nums.length;
          int []ans=new int [n];
          ans[0]=nums[0];
          //前缀积
          for(int i=1;i<n;i++){
              ans[i]=ans[i-1]*nums[i];
          }
          int l=1;
          int r=1;
          for(int i=n-1;i>=0;i--){
              if(i-1>=0){
                  l=ans[i-1];
              }else{
                  l=1;
              }
              //后缀积
              if(i+1<n){
                  r*=nums[i+1];
              }
  
              ans[i]=l*r;
          }
          return ans;
      }
  }
  ```

  



## 560. 和为 K 的子数组（前缀和+HashMap）

难度中等1884

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的连续子数组的个数* 。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

- 模拟前缀和sum数组得计算

  ```java
  class Solution {
      public int subarraySum(int[] nums, int k) {
          //因为有负数，0.所以前面可能出现重复的前缀和。
          //不能用set,得用map
          HashMap<Integer,Integer>map=new HashMap<>();
          int ans=0;
          int s=0;
          //相当于int []sum=new int [n+1];sum[0]=0;    //这个前缀数组
          map.put(0,1);
          for(int i=0;i<nums.length;i++){
              s+=nums[i];
              if(map.containsKey(s-k)){
                  ans+=map.get(s-k);
              }
              map.put(s,map.getOrDefault(s,0)+1);
          }
          return ans;
      }
  }
  ```

  

## 316. 去除重复字母（单调栈+贪心）

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb
```

- 跟字典序相关可以考虑单调栈	

  - 拿不到后续信息可以先遍历下，不影响

  ```java
  import java.util.HashSet;
  import java.util.Stack;
  
  class Solution {
      public String removeDuplicateLetters(String s) {
          //先记录个数
          int n=s.length();
          int []a=new int [26];
          for(int i=0;i<n;i++){
              a[s.charAt(i)-'a']++;
          }
  
          //单调栈
          //新的元素和栈顶元素比较
          //栈顶元素剩余个数为1，直接入栈。
          //新元素<栈顶元素  且栈顶元素不剩余1   栈顶元素不断出栈，新元素入栈
          //新元素>栈顶元素  直接入栈
          //新元素=栈顶   不处理
          Stack<Character>stack=new Stack<>();
          StringBuilder ans=new StringBuilder();
          HashSet<Character>set=new HashSet<>();
          for(int i=0;i<n;i++){
              char ch=s.charAt(i);
              a[ch-'a']--;
              if(stack.isEmpty()){
                  stack.push(ch);
                  set.add(ch);
              }else{
                  if(!set.contains(ch)){
                      while (!stack.isEmpty() && stack.peek()>ch && a[stack.peek()-'a']!=0){
                          set.remove(stack.peek());
                          stack.pop();
                      }
                      set.add(ch);
                      stack.push(ch);
                  }
              }
          }
          
          while (!stack.isEmpty()){
              ans.insert(0,stack.pop());
          }
          return ans.toString();
      }
  }
  ```

## 402.移掉 K 位数字(单调栈+贪心)

难度中等939

给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

**示例 1 ：**

```
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

**示例 2 ：**

```
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**示例 3 ：**

```
输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。
```

- 升序最小

  ```java
  import java.util.Stack;
  
  class Solution {
      //单调栈+贪心
      //上升序列是字典序最小
      public String removeKdigits(String num, int k) {
          Stack<Integer> s=new Stack<>();
          //拿到一个上升序列
          for(int i=0;i<num.length();i++){
              int e=Integer.parseInt(num.charAt(i)+"");
              while (k!=0 && !s.isEmpty() && s.peek()>e){
                  s.pop();
                  k--;
              }
              s.push(e);
          }
          //k还没用完
          while (k!=0 && !s.isEmpty()){
              s.pop();
              k--;
          }
          //结果处理
          StringBuilder ans=new StringBuilder();
          while (!s.isEmpty()){
              ans.insert(0,s.pop());
          }
          int size=ans.length();
          for(int i=0;i<size;i++){
              if(ans.charAt(0)=='0'){
                  ans.deleteCharAt(0);
              }else {
                  break;
              }
          }
          //return Integer.parseInt(ans.toString())+"";//处理前置0   结果可能超出int范围
          return ans.length()==0?"0":ans.toString();
          
      }
  }
  ```

## 321. 拼接最大数（分治+贪心+拟单调栈）

难度困难531

给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。

**说明:** 请尽可能地优化你算法的时间和空间复杂度。

**示例 1:**

```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```

**示例 2:**

```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```

**示例 3:**

```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

- 两个数组去除k个元素不会求，但是一个数组的去除k个会求

  - 且能够通过合并的到最优结果，所以考虑分治
  - 求的过程用贪心+单调栈

  ```java
  import java.util.Stack;
  
  class Solution {
      //分治+贪心
      public int[] maxNumber(int[] nums1, int[] nums2, int k) {
          int len=Math.min(nums1.length,nums2.length);
          len=Math.min(k,len);   //len可能已经大于k了
          int []a=nums1.length==len?nums1:nums2;  //短的一个
          int []b=a==nums1?nums2:nums1; //不是a的那一个
          int []ans=new int[k];
  
          //可以从0开始
          int st=0;
          if(k>=Math.max(nums1.length,nums2.length)){
              st=k-Math.max(nums1.length,nums2.length);
          }
          for(int i=st;i<=len;i++){
              int []m=getNums(a,i);
              int []n=getNums(b,k-i);
              ans=merge(m,n,ans,k);
          }
          return ans;
      }
  
      //拟单调栈
      private int[] getNums(int []nums,int n){
          Stack<Integer> s=new Stack<>();
          //一直取到n个
          //n个之后，若大于栈顶元素，且后续还有补充至n个，则栈顶一直出栈。新元素入栈
          for(int i=0;i<nums.length;i++){
              while(s.size()+nums.length-i>n && !s.isEmpty() && s.peek()<nums[i]){
                  s.pop();
              }
              if(s.size()<n){
                  s.add(nums[i]);
              }
          }
          int []t=new int[n];
          for(int i=n-1;i>=0;i--){
              t[i]=s.pop();
          }
          return t;
      }
      //尽量取大的值
      private int[] merge(int []m,int []n,int []ans,int k){
          int []t=new int[k];
          int x=0;
          int y=0;
          for(int i=0;i<k;i++){
              if(y==n.length){
                  t[i]=m[x++];
              }else if(x==m.length){
                  t[i]=n[y++];
              }else{
                  if(m[x]>n[y]){
                      t[i]=m[x++];
                  }else if(m[x]<n[y]){
                      t[i]=n[y++];
                  }else {
                      //等于。取最有价值的那一条
                      for(int j=1;j<n.length;j++){
                          if(x+j<m.length && y+j<n.length){
                              if(m[x+j]>n[y+j]){
                                  t[i]=m[x++];
                                  break;
                              }
                              if(m[x+j]<n[y+j]){
                                  t[i]=n[y++];
                                  break;
                              }
                          }
                          //x已经结尾则取y  给y更多选择空间
                          if(x+j==m.length){
                              t[i]=n[y++];
                              break;
                          }
                          if(y+j==n.length){
                              t[i]=m[x++];
                              break;
                          }
                      }
                  }
              }
          }
  
          //比较值
          for(int i=0;i<k;i++){
              if(t[i]>ans[i]){
                  //ans=t;   改变的是引用
                  return t;
              }
              if(t[i]<ans[i]){
                  return ans;
              }
          }
          return ans;
      }
  
  }
  ```

## 904. 水果成篮（滑动窗口）

难度中等469

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

 

**示例 1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例 2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

- 滑动窗口

  - 问题是要维护下出栈的顺序，将HashMap转化为ArrayList吧

  ```java
  import java.util.ArrayList;
  import java.util.HashMap;
  
  class Solution {
      public int totalFruit(int[] fruits) {
          //滑动窗口，最多保留两个篮子
          HashMap<Integer,Integer> w=new HashMap<>();
          //若篮子类型满了，新的加进来，则把结束位置最小的篮子去掉
          //只有两个篮子而已
          int c=0;
          int ans=0;
          for(int i=0;i<fruits.length;i++){
              if(w.size()<2 || w.size()==2 && w.containsKey(fruits[i])){
                  c++;
              }else{
                  //取出最最左边
                  ArrayList<Integer[]>list=new ArrayList<>();
                  w.forEach((k,v)->{
                      list.add(new Integer[]{k,v});
                  });
                  if(list.get(0)[1]<list.get(1)[1]){
                      w.remove(list.get(0)[0]);
                      c=i-list.get(0)[1];
                  }else {
                      w.remove(list.get(1)[0]);
                      c=i-list.get(1)[1];
                  }
              }
              w.put(fruits[i],i);   //一定会更新
              ans=Math.max(ans,c);
          }
          return ans;
      }
  }
  ```

## 572. 另一棵树的子树（dfs+暴力）

难度简单897

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)

```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```

- 要到树末尾才算

  - 直接dfs+暴力

  ```java
  class Solution {
      
      public boolean isSubtree(TreeNode root, TreeNode subRoot) {
          TreeNode node=root;
          Stack<TreeNode>stack=new Stack<>();
          boolean ans=false;
          while(node!=null || !stack.isEmpty()){
              //找最左
              while(node!=null){
                  stack.push(node);
                  node=node.left;
              }
              //访问
              node=stack.pop();
              if(node.val==subRoot.val){
                  if(check(node,subRoot)){
                      ans=true;
                  }
              }
              node=node.right;
          } 
          return ans;   
      }
  	//要到树末尾
      private boolean check(TreeNode r,TreeNode s){
          if(r==null && s==null){
              return true;
          }
          if(r==null || s==null || r.val!=s.val){
              return false;
          }
          return check(r.left,s.left) && check(r.right,s.right);
      }
  
  }
  ```

  



## 198. 打家劫舍（dp）

难度中等2521

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

- 最简单的dp类型

  ```java
  class Solution {
      public int rob(int[] nums) {
          int n=nums.length;
          int []dp=new int[n+1];
          dp[1]=nums[0];
          for(int i=1;i<n;i++){
              dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);
          }
          return dp[n];
      }
  }
  ```

## 213. 打家劫舍 II(环形dp)

难度中等1329

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

- dp

  - 这居然可以直接只考虑开头或结尾中的一个

  ```java
  class Solution {
      public int rob(int[] nums) {
          int n=nums.length;
          if(n==1){
              return nums[0];
          }
          if(n==2){
              return Math.max(nums[0],nums[1]);
          }
          //不要结尾[0,n-2]   不要开头[0,n-1]
          return Math.max(getMon(nums,0,n-2,n),getMon(nums,1,n-1,n));
      }
      private int getMon(int []nums,int st,int end,int n){
          int []dp=new int[n];
          dp[1]=nums[st];
          int x=2;
          for(int i=st+1;i<=end;i++){
              dp[x]=Math.max(dp[x-1],dp[x-2]+nums[i]);
              x++;
          }
          return dp[n-1];
      }
  }
  ```

## 300. 最长递增子序列（dp）

难度中等3129

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

- dp吧，

  ```java
  class Solution {
      //用dp吧，尽管O(n2)不用dp你都不知道怎么写
      //还有贪心+二分 O(nlgn)
      public int lengthOfLIS(int[] nums) {
          int n=nums.length;
          int []dp=new int [n];
          int ans=1;
          for(int i=0;i<n;i++){
              dp[i]=1;
              for(int j=0;j<i;j++){
                  if(nums[j]<nums[i]){
                      dp[i]=Math.max(dp[i],dp[j]+1);
                  }
              }
              ans=Math.max(ans,dp[i]);
          }
          return ans;
      }
  }
  ```

  

## 263. 丑数（直接求）

难度简单382

**丑数** 就是只包含质因数 `2`、`3` 和 `5` 的正整数。

给你一个整数 `n` ，请你判断 `n` 是否为 **丑数** 。如果是，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：n = 6
输出：true
解释：6 = 2 × 3
```

**示例 2：**

```
输入：n = 1
输出：true
解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
```

**示例 3：**

```
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```

- 只是判断，直接递归求

  ```java
  class Solution {
      public boolean isUgly(int n) {
          if(n==0){
              return false;
          }
          if(n==1){
              return true;
          }
          if(n%2==0){
              return isUgly(n/2);
          }
          if(n%3==0){
              return isUgly(n/3);
          }
          if(n%5==0){
              return isUgly(n/5);
          }
          return false;
      }
  }
  ```

  

## 264. 丑数 II(最小堆筛选  或者 dp)

难度中等1056

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

 

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

**示例 2：**

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

- 最小堆

  ```java
  import java.util.HashSet;
  import java.util.PriorityQueue;
  
  class Solution {
      //从当前最小的丑数开始枚举
      //丑数x的倍数2x,3x,5x是丑数。然后把结果放入最小堆
      //非丑数的任意倍都不是丑数
      public int nthUglyNumber(int n) {
          int[]mul={2,3,5};
          PriorityQueue<Long> q=new PriorityQueue<>();
          HashSet<Long> set=new HashSet<>();//去重
          long ans=0;
          q.add(1l);
          set.add(1l);
          for(int i=0;i<n;i++){
              ans=q.poll();
              for(int j=0;j<mul.length;j++){
                  if(!set.contains(ans*mul[j])){
                      set.add(ans*mul[j]);
                      q.add(ans*mul[j]);
                  }
              }
          }
          return (int)ans;
      }
  }
  ```

- dp

  - 最小堆保留了很多没有用到的值

  ```java
  class Solution {
      //三指针，记录2，3，5要乘的数。每个数只能够乘一次，所以可以递增
      public int nthUglyNumber(int n) {
          long []dp=new long [n];
          dp[0]=1;
          int p2=0;
          int p3=0;
          int p5=0;
          for(int i=1;i<n;i++){
              long a2=dp[p2]*2;
              long a3=dp[p3]*3;
              long a5=dp[p5]*5;
              long min=Math.min(a2,Math.min(a3,a5));
              dp[i]=min;
              //若等于则++，为了防止重复
              if(a2==min){
                  p2++;
              }
              if(a3==min){
                  p3++;
              }
              if(a5==min){
                  p5++;
              }
          }
          return (int)dp[n-1];
      }
  }
  ```

  

## 409. 构造最长回文串（贪心）

难度简单522

给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。

在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。

 

**示例 1:**

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**示例 2:**

```
输入:s = "a"
输出:1
```

**示例 3：**

```
输入:s = "aaaaaccc"
输出:7
```

- 这是构造一个最长回文串，不是求已有的最长串

  ```java
  class Solution {
      public int longestPalindrome(String s) {
          int n=s.length();
          int ans=0;
          int []c=new int [256];
          //统计出现个数
          for(int i=0;i<n;i++){
              c[s.charAt(i)]++;
          }
          //把成对先拿了
          for(int i='a';i<='z';i++){
              if(c[i]!=0 && c[i]>1){
                  ans+=c[i]/2*2;
              }
          }
          for(int i='A';i<'Z';i++){
              if(c[i]!=0 && c[i]>1){
                  ans+=c[i]/2*2;
              }
          }
          //中间还能放一个
          if(ans!=n){
              ans++;
          }
          return ans;
      }
  
  }
  ```

## 179. 最大数(比较器+假设既定法)

难度中等1116

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

 

**示例 1：**

```
输入：nums = [10,2]
输出："210"
```

**示例 2：**

```
输入：nums = [3,30,34,5,9]
输出："9534330"
```

- 666，原来可以这样

  - 拼接后再比较大小

  ```java
  class Solution {
      public String largestNumber(int[] nums) {
          int n=nums.length;
          String []s=new String[n];
          for(int i=0;i<n;i++){
              s[i]=String.valueOf(nums[i]);
          }
          Arrays.sort(s,(x,y)->(x+y).compareTo(y+x));
          StringBuilder ans=new StringBuilder();
          for(int i=n-1;i>=0;i--){
              ans.append(s[i]);
          }
          return ans.charAt(0)=='0'?"0":ans.toString();
      }
  }
  ```

- 最捞的方法

  - 不想多说什么。。

  ```java
  class Solution {
      public String largestNumber(int[] nums) {
          int n=nums.length;
          //全是0
          int st=0;
          while(st<n){
              if(nums[st]!=0){
                  break;
              }
              st++;
          }
          if(st==n){
              return "0";
          }
          String []s=new String[n];
          for(int i=0;i<n;i++){
              s[i]=nums[i]+"";
          }
          Arrays.sort(s,(x,y)->{
              if(x.equals(y)){
                  return 0;
              }
              int min=Math.min(x.length(),y.length());
              for(int i=0;i<min;i++){
                  if(x.charAt(i)>y.charAt(i)){
                      return 1;
                  }else if(x.charAt(i)<y.charAt(i)){
                      return -1;
                  }
              }
              
              if(x.length()==min){
                  int a=0;
                  for(int i=min;i<y.length();i++){
                      if(y.charAt(i)>x.charAt(a)){
                          return -1;
                      }else if(y.charAt(i)<x.charAt(a)){
                          return 1;
                      }
                      a++;
                      a%=min;
                  }
                  for(int i=0;i<min;i++){
                      if(x.charAt(i)<y.charAt(y.length()-1)){
                          return -1;
                      }else if(x.charAt(i)>y.charAt(y.length()-1)){
                          return 1;
                      }
                  }
              }else{
                  int a=0;
                  for(int i=min;i<x.length();i++){
                      if(x.charAt(i)>y.charAt(a)){
                          return 1;
                      }else if(x.charAt(i)<y.charAt(a)){
                          return -1;
                      }
                      a++;
                      a%=min;
                  }
                  for(int i=0;i<min;i++){
                      if(y.charAt(i)<x.charAt(x.length()-1)){
                          return 1;
                      }else if(y.charAt(i)>x.charAt(x.length()-1)){
                          return -1;
                      }
                  }
              }
  
              return 0;
              
          });
          StringBuilder ans=new StringBuilder();
          for(int i=n-1;i>=0;i--){
              ans.append(s[i]);
          }
          return ans.toString();
      }
  }
  ```

## 406. 根据身高重建队列(贪心+双排序)

难度中等1593

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

- 3

  ```java
  class Solution {
      //贪心+双排序   。第二个排序相当于插入某位置（插队）
      public int[][] reconstructQueue(int[][] people) {
          //按照身高进行排序 第i个元素前面有i-1个大于等于它的
          Arrays.sort(people,(x, y)->{
              if(x[0]==y[0]){
                  return x[1]-y[1];     //身高相等，则按照people[1]升序    
              }
              return y[0]-x[0];  //身高不相等，则按照身高降序
          });
          //新插入的元素比旧的元素都小，所以只要找到插入位置即可
          //这个位置就在people[i][1]
          List<int []> ans=new ArrayList<>();
          for(int[]p:people){
              ans.add(p[1],p);//ArrayList.add(index,e);  没有insert方法，只有这个
          }
          return ans.toArray(new int[0][0]); //传递一个最终类型的空数组
      }
  
  }
  ```

  

## 455. 分发饼干（贪心）

难度简单693

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

- 简单贪心

  ```java
  class Solution {
      public int findContentChildren(int[] g, int[] s) {
          Arrays.sort(g);
          Arrays.sort(s);
          int x=0;
          for(int i=0;i<s.length;i++){
              if(x==g.length){
                  break;
              }
              if(s[i]>=g[x]){
                  x++;
              }
          }
          return x;
      }
  }
  ```

  

## 134. 加油站(贪心+更新i)

难度中等1210

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

 

**示例 1:**

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
```

- 更新i，让时间复杂度降低到O(n)

  ```java
  class Solution {
      public int canCompleteCircuit(int[] gas, int[] cost) {
          //直接算，更新i让时间复杂度降低到O(n)
          int n=gas.length;
          for(int i=0;i<n;i++){
              //走一圈
              if(gas[i]-cost[i]>=0){
                  //剩余的油
                  int x=0;
                  for(int j=0;j<n;j++){
                      x+=gas[(i+j)%n];
                      x-=cost[(i+j)%n];
                      if(x<0){
                          //i还没走完一圈，可以更新i
                          if(i+j<n){
                              i+=j;
                          }else{
                              //走了一圈还没有拿到最终值
                              return -1;
                          }
                          break;
                      }
                      //走了最后一个
                      if(j==n-1){
                          return i;
                      }
                  }
              }
          }
          return -1;
      }
  }
  ```

  

## 236. 二叉树的最近公共祖先(一次dfs，结果和返回值不同，在dfs中处理结果)

难度中等2233

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示**

p树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。

- 一次dfs

  - 不要想着两次，通过子树的返回值来处理结果。都处理就只相当于遍历一次树。O(n)

  ```java
  class Solution {
      //dfs返回结果和所求答案不一致。但是有关系
      TreeNode ans=null;
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          check(root,p,q);
          return ans;
      }
  
      //在一次dfs过程中取结果，不用再暴力一次
      //用boolean存储子树的结果，在当前节点根据子树结果进行判断。满足则更新答案
      private boolean check(TreeNode r,TreeNode p, TreeNode q){
          if(r==null){
              return false;
          }
          boolean left=check(r.left,p,q);
          boolean right=check(r.right,p,q);
          //r是p或者q中一个，且子节点有另一个
          //r的子节点各有一个
          //注意运算符优先级问题，不记得就都加括号
          if(((r.val==p.val || r.val==q.val) && (left || right) ) || (left && right) ){
              ans=r;
          }
          //至少有一个都可以返回true。两个没关系，因为结果已经被处理了
          return r.val==p.val ||r.val==q.val || left || right;
      }
  }
  ```

  

## 222. 完全二叉树的节点个数(dfs吧)

难度中等915

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

- 更好的解法是利用完全二叉树的性质来降低dfs的时间复杂度

- dfs

  ```java
  class Solution {
      public int countNodes(TreeNode root) {
          if(root==null){
              return 0;
          }
          return countNodes(root.left)+countNodes(root.right)+1;
      }   
  }
  ```

## 230. 二叉搜索树中第K小的元素（中序dfs）

难度中等723

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

- 除非转化为AVL，平衡二叉搜索树。能够提高查找速度？

- 中序遍历

  ```java
  
  class Solution {
      //前序遍历
      public int kthSmallest(TreeNode root, int k) {
          TreeNode node=root;
          Stack<TreeNode> stack=new Stack<>();
          while(node!=null || !stack.isEmpty()){
              while(node!=null){
                  stack.push(node);
                  node=node.left;
              }
              node=stack.pop();
              k--;
              if(k==0){
                  return node.val;
              }
              node=node.right;
          }
          return -1;
      }
  } 
  ```

## 543. 二叉树的直径(返回值和结果不一致的dfs)

难度简单1300

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

- 大概就是求二叉树的最长路径

  ```java
  
  class Solution {
      //一条边长度为1，寻找最长路径
      int ans=0;
      public int diameterOfBinaryTree(TreeNode root) {
          dfs(root);
          return ans;
      }
  
      private int dfs(TreeNode root){
          if(root==null){
              return 0;
          }
          int left=dfs(root.left);
          int right=dfs(root.right);
          //左加右
          ans=Math.max(ans,left+right);
          return Math.max(left,right)+1;//左和右只能要一个
      }
  }
  ```

  

## 98. 验证二叉搜索树(中序dfs)

难度中等1971

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

- 直接验证

  ```java
  
  class Solution {
      public boolean isValidBST(TreeNode root) {
          Stack<TreeNode>stack=new Stack<>();
          TreeNode node=root;
          TreeNode pre=null;
          while(node!=null || !stack.isEmpty()){
              while(node!=null){
                  stack.push(node);
                  node=node.left;
              }
              node=stack.pop();
              if(pre!=null && pre.val>=node.val){
                  return false;
              }
              pre=node;
              node=node.right;
          }
          return true;
      }
  }
  ```

## 669. 修剪二叉搜索树(不是中序dfs，是往上构造dfs)

难度中等789

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

```
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
```

- 就是普通的dfs，不断往上构造

  ```java
  class Solution {
      //看起来示例二不讲理。但是这就是二叉搜索树
      //不要一看到二叉搜索树就想到中序
      //这题不是用中序
      public TreeNode trimBST(TreeNode root, int low, int high) {
          if(root==null){
              return null;
          }
          if(root.val<low){
              return trimBST(root.right,low,high);
          }else if(root.val>high){
              return trimBST(root.left,low,high);
          }else{
              root.left=trimBST(root.left,low,high);
              root.right=trimBST(root.right,low,high);
              return root;
          }
      }
  }
  ```

## 99. 恢复二叉搜索树(非递归中序处理)

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)

```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

 

- 先中序遍历，然后处理

  - 这么看非递归中序真的很不错

  ```java
  class Solution {
      //二叉搜索树没值相等的节点
      //没有要求，则交换节点就只交换值
      //若真的要交换节点，则应该用stack存储遍历顺序
      public void recoverTree(TreeNode root) {
  
          TreeNode node=root;
          Stack<TreeNode>stack=new Stack<>();
          TreeNode pre=null;
          List<TreeNode>ans=new ArrayList<>();
          while(node!=null || !stack.isEmpty()){
              while(node!=null){
                  stack.push(node);
                  node=node.left;
              }
              node=stack.pop();
              if(pre!=null && pre.val>node.val){
                  ans.add(pre);
                  ans.add(node);
              }
              pre=node;
              node=node.right;
          }
          //无论是相邻位置逆序。还是有两组逆序。都是最前和最后交换
          int t=ans.get(0).val;
          ans.get(0).val=ans.get(ans.size()-1).val;
          ans.get(ans.size()-1).val=t;
          
      }
  }
  ```

  

## 662. 二叉树最大宽度(bfs层序遍历+编号)

难度中等554

给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。

树的 **最大宽度** 是所有层中最大的 **宽度** 。

每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。

题目数据保证答案将会在 **32 位** 带符号整数范围内。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg)

```
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg)

```
输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg)

```
输入：root = [1,3,2,5]
输出：2
解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
```

- 就bfs吧，这里还得自己定义一个节点 类

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      //层序遍历就是广度优先遍历吧
      public int widthOfBinaryTree(TreeNode root) {
          //层序放null？
          int  ans=1;
          //给节点编号
          List<Pair> list=new ArrayList<>();
          list.add(new Pair(root,1l));
          while(list.size()!=0){
              List<Pair>t=new ArrayList<>();
              for(Pair e:list){
                  long n=e.getNum();
                  TreeNode node=e.getNode();
                  if(node.left!=null){
                      t.add(new Pair(node.left,(long)2*n));
                  }
                  if(node.right!=null){
                      t.add(new Pair(node.right,(long)2*n+1));
                  }
              }
              if(t.size()>1){
                  ans=(int)Math.max(ans,t.get(t.size()-1).getNum()-t.get(0).getNum()+1);
              }
              //else{
              //    break;    //不能只有一个节点就停止bfs，因为一个节点也可能开花
              //}
              list=t;
          }
          return ans;
      }
      //还是要定义节点类
      class Pair{
          TreeNode node;
          long num;
          public Pair(TreeNode node,long num){
              this.node=node;
              this.num=num;
          }
          public TreeNode getNode(){
              return node;
          }
          public long getNum(){
              return num;
          }
      }
  }
  ```

## 279. 完全平方数(dp)

难度中等1675

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

- 就dp

  ```java
  class Solution {
      public int numSquares(int n) {
          //计算所有平方数 100个
          int []a=new int[100];
          for(int i=0;i<100;i++){
              a[i]=(i+1)*(i+1);
          }
          int []dp=new int[n+1];
          //要对n进行dp，O(n)就O(n)吧
          for(int i=1;i<=n;i++){
              int min=Integer.MAX_VALUE;
              for(int j=0;j<100;j++){
                  if(i>=a[j]){
                      min=Math.min(min,dp[i-a[j]]+1);
                  }
              }
              dp[i]=min;
          }
          return dp[n];
      }
  }
  ```

## 1590. 使数组和能被 P 整除(同余+前缀和+Hash)

难度中等217

给你一个正整数数组 `nums`，请你移除 **最短** 子数组（可以为 **空**），使得剩余元素的 **和** 能被 `p` 整除。 **不允许** 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 `-1` 。

**子数组** 定义为原数组中连续的一组元素。

 

**示例 1：**

```
输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
```

**示例 2：**

```
输入：nums = [6,3,5,2], p = 9
输出：2
解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。
```

**示例 3：**

```
输入：nums = [1,2,3], p = 3
输出：0
解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。
```

- 

  - Hash可以是HashMap或者HashSet，当然这题是HashMap
  - 同余关系去看Note.md，用于处理两数相减mod p=0的情况
  - 前缀和一般要有一个dp[0]    dp[n+1] 多一位

  ```java
  import java.util.HashMap;
  
  class Solution {
      public int minSubarray(int[] nums, int p) {
          int n=nums.length;
          long []s=new long[n+1];
          //要多一个dp[0] 才能够拿到所有的子数组和
          for(int i=1;i<=n;i++){
              s[i]=s[i-1]+nums[i-1];
          }
          long x=s[n];
          if(x%p==0){ //判断一下只是提高效率  
              return 0;
          }
          int ans=n;
          HashMap<Long,Integer> map=new HashMap<>();//记录最新出现位置
          for(int i=0;i<=n;i++){
              map.put(s[i]%p,i); //存进去的是 l%p    不能是l
              // l%p=(r-x)%p    若存在这样的l    l%p=( (r-x)%p + p )%p     r-x是可能是负数
              long t=(s[i]%p-x%p+p)%p;
              if(map.containsKey(t)){
                  ans=Math.min(i-map.get(t),ans);
              }
          }
          return ans<n?ans:-1; //ans=n是将所有元素都去除。题目不允许
      }
  }
  ```


## 40. 组合总和 II（dfs+剪枝+去重）

难度中等1313

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

- 不是我写的，我只能说很妙

  ```java
  class Solution {
      //排序+剪枝
      int []a;
      int n;
      List<Integer> path=new ArrayList<>();
      List<List<Integer>>ans=new ArrayList<>();
      public List<List<Integer>> combinationSum2(int[] candidates, int target) {
          a=candidates;
          n=candidates.length;
          Arrays.sort(a);
          dfs(0,target);
          return ans;
      }
  
      //在当前层进行剪枝
      private void dfs(int dept,int tar){
          if(tar==0){
              ans.add(new ArrayList<>(path));
              return;
          }
          for(int i=dept;i<n;i++){
              //排序，后面的更大
              if(tar-a[i]<0){
                  break;
              }
              //当前层只能有一个相同的
              if(i>dept && a[i]==a[i-1]){
                  continue;
              }
              path.add(a[i]);
              //这里对i进行dfs，因为前面的都用过了
              dfs(i+1,tar-a[i]);
              path.remove(path.size()-1);
          }
      }
  }
  ```


## 1780. 判断一个数字是否可以表示成三的幂的和

难度中等115

给你一个整数 `n` ，如果你可以将 `n` 表示成若干个不同的三的幂之和，请你返回 `true` ，否则请返回 `false` 。

对于一个整数 `y` ，如果存在整数 `x` 满足 `y == 3x` ，我们称这个整数 `y` 是三的幂。

 

**示例 1：**

```
输入：n = 12
输出：true
解释：12 = 31 + 32
```

**示例 2：**

```
输入：n = 91
输出：true
解释：91 = 30 + 32 + 34
```

- dfs

  - 时间复杂度最高的方式

  ```java
  class Solution {
      boolean ans;
      int N=20;
      public boolean checkPowersOfThree(int n) {
          int []a=new int[N];  //3的十九次方不超出范围
          for(int i=0;i<N;i++){
              a[i]=(int)Math.pow(3,i);
          }
          dfs(a,n,0,0);
          return ans;
      }
      private void dfs(int []a,int n,int sum,int x){
          if(sum>n || x>=N){
              return;
          }
          if(sum==n){
              ans=true;
              return;
          }
          dfs(a,n,sum,x+1);
          dfs(a,n,sum+a[x],x+1);
      }
  }
  ```

- 直接模拟

  - 类似于转化为三进制，从大的开始比较，若有则直接减去
  - 27>9+3+1 若一个数n大于27，则27处的三进制一定是要为1。因为后面的数的和小于27
  - 同理8>4+2+1

  ```java
  class Solution {
      public boolean checkPowersOfThree(int n) {
          int N=20;
          int []a=new int[N];
          for(int i=0;i<N;i++){
              a[i]=(int)Math.pow(3,i);
          }
          for(int i=N-1;i>=0;i--){
              if(n>=a[i]){
                  n-=a[i];
              }
          }
          return n==0;
      }
  }
  ```

## 快速幂乘

- 求解a的b次方

- 若b是奇数，则ans=a*a的b-1次方

- 若b是偶数，则ans=a的b/2次方*a的b/2次方

- 可以用二进制从低位开始算

  ```java
  public long qmul(long a,long b){
      long ans=1;
      while(b>0){
          if((b&1)==1){    //某位为1
              ans*=a;
          }
          a*=a;
          b>>=1;
      }
      return ans;
  }
  ```

## 后序遍历

- 先左，再右，最后根
- 用于求一些左右子树返回结果 的递归

## 区间最值查询（倍增）

- 直接拿一个代码得了

- 有多次查询可以先构造好答案集合

  ```java
      //区间最值查询
      public static void main(String []args){
          Scanner in =new Scanner(System.in);
          int n=in.nextInt();//数组长度
          int m=in.nextInt();//m次查询
          int [][]d=new int[n+1][40];
          for(int i=1;i<=n;i++){
              d[i][0]=in.nextInt();
          }
          for(int j=1;(1<<j)<=n;j++){
              for(int i=1;i+(1<<j)-1<=n;i++){
                  d[i][j]=Math.min(d[i][j-1],d[i+(1<<(j-1))][j-1]);
              }
          }
  
          for(int i=0;i<m;i++){
              int l=in.nextInt();
              int r=in.nextInt();
              int k=(int)Math.log(r-l+1);
              System.out.println(Math.min(d[l][k],d[r-(1<<k)+1][k]));
          }
      }
  ```

  