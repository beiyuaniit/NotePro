## 步骤

- 和软件工程思想一样。写代码只是整个环节的一小部分
- 在纸上写写思路，处理特殊 情况才是首要任务
- 就像数学一样，要提前验证正确性

## 数据结构本身的特性

- Stack的先进后出。
- 辅助栈
- HashMap的一一映射关系
- HashSet。无需不重复
- 用ArrayList来模拟只有头节点的链表
- 优先考虑boolean数组而不是HashSet

## 双指针
- 从后面开始想

- 数据、链表：一边遍历，一边完成一些事

## 动态规划

- 在于怎么跳回去

## 利用已知条件

- 最大值为n-1
- 数据全部有序或部分有序

## 二分法

- 注意边界条件

## 关于代码量

- 行数多点没关系
- 关键是逻辑清晰。时间、空间复杂度低点就行

## 中间值

- 用变量保存中间结果。
  - 第i天前的最小值

## 原则

- 不轻易改变原引用指向的值，除非特别说明。
- 有时候改变了反而让程序更加复杂，老老实实声明新的变量
## 原地算法
- 输出是对输入的改变
- 启发
   -  用输入来存储一些中间变量

## 只有小写或大写字母

- 可用int[26]存char和int的映射关系。比用HashMap存储快很多

## 树的顺序存储结构

- 总的来说，要想完整表示一颗二叉树，要有前序、中序或者中序、后序遍历的两个数组
- 或者类似于并查集一样存储其父节点？
- 在这样的数据结构上的dfs的return条件经常是left<right

## 注意

- 有时候太过复杂的方法、有太多限制的方法可以直接抛弃了。
- 多多观察结果的结构
- 超出类型限制反向越界 int long
- 若是2个指针，则可以while(left<=right)    而不用每次想到for()
- 逆向思维啥的
- m次询问，则可以事先构造后结果集，询问时直接返回