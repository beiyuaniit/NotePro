-面向过程的优点：快速开发小程序

-类
	是引用数据类型
	包含属性和方法

-成员变量系统有默认值（一般是0类），局部变量没有默认值

-java没有指针，程序员不能直接操作堆区，只能可以通过引用（对象名）去访问新建的对象
 引用的字面量是对象的地址，可以访问对象数据，可以指向新的对象。没其他功能了
 不能通过类名访问属性和方法
	
-JVM主要三内存区：
	方法区：方法代码，静态数据
	桟区：方法调用时在桟区分配空间
	堆区：对象

-一个线程有一个桟区，所有线程共用一个方法区和一个堆区

-GC垃圾回收机制主要针对堆区数据

-空指针（引用）异常
	当引用指向null时，如：对象名=null；再访问属性和方法会报错
	
-面向对象的封装性：
	所有属性私有化（private）
	对外提供简单接口
		set修改
		get获取

-构造方法
	又称为构造器、构造函数、Constructor
	结构：
		修饰符 方法名 （参数）{}
		不写返回值
		方法名和类名一致
		
	调用
		new 方法名（参数）
	返回值：
		返回值类型是类本身类型，所以不用写返回值类型，也不用写return
	支持重载
	提供了构造方法后系统不再提供默认无参构造


-普通方法/变量调用：
	static：类名.方法名/变量		对象名.方法名/变量
	无static：对象名.方法名/变量

-引用是址传递

-this关键字
	
	本质：创建的对象的地址
	调用本对象中的属性或者方法，解决实例变量和参数同名问题
	创建对象后指向了对象本身，同一个类N个对象就有N个this引用
	注意；
		this不能写在static修饰的方法中，因为static方法属于类
		可以省略不写
	this（参数）;
		只能出现在构造方法的第一行，用来调用本类其他构造方法
		如：在无参构造里面添加有参构造来设置默认值
		
-静态方法static：
	共用的方法，不被对象所特有
	只能访问类中的静态数据
	无法访问类中的非静态成员变量和方法 （实例变量和实例方法）
	因为没有this，也就是没有对象存在（不能用this，因为静态变量不属于对象
	要想访问得先创建该类的对象（实例化），通过对象名访问
	不是对象特有的一般定义为静态，如工具类
	
-声明为静态数据可以节省内存开销
 
 -实例语句/代码块
	类中纯粹用{}括起来的代码
	在构造函数执行开始前执行，每创建一个对象执行一次
	平时用得非常少
	
-静态代码块
	static {}
	类加载时执行，并且只执行一次
	用处：监视该执行期的行为
 
-继承：
	格式：
		修饰符	class	类名	extends	父类{}
	不支持继承：
		私有数据
		构造方法
		
-方法覆盖（重写）
	就重写
	静态方法不支持重写
	覆盖不针对属性
	
-向上类型转型upcasting
	子类型->父类型
	又称为自动类型转换

-向下则反之
	要强制类型转换
	
-多态
	动态方法（编译时是静态绑定a当做Animal类来检查语法，运行时是动态绑定，也就是实际创建的是Cat对象）
		父类引用指向子类对象（自动转换）
			如：Animal  a=new Cat（）；
			调用a其实就是调用Cat类的一个对象
		要求：父类中也有子类的同名方法
		用法：
			只能调用父类和子类中都有的方法，如果子类没有重写则调用父类的
			不能直接调用子类中特有的方法
		要访问子类中特有的
			向下类型转换
				Cat c=（Cat）a；
				通过新建的c引用访问
				
-所以感觉重写实现多态比较好

-instanceof运算符
	格式:
		（引A instanceof 数据类型B）
	作用：
		判断A的类型是否是B（可用于类的判断）
		是返回true
	此处可以校验向下类型转换的合法性
	
-多态的作用
	降低程序耦合度，提高扩展力（不用在父类中重写所有功能相似的子类方法）
	调用的类只需要对父类进行操作即可
	大型程序开发中作用就明显了
	
-final修饰
	类：无法被继承
	方法：无法被重写
	变量：赋值后无法改变值（只能赋值一次）
	实例变量：必须手动赋值（不然报错），赋值后无法改变值
			  可以声明时赋值，也可以声明后在构造方法中赋值
	引用：不能指向其他对象了，无法被GC回收（引用的值是地址，地址不能再改变）
		  但是可以修改对象的数据（通过地址访问）

-final一般和static联合使用，被修饰的称为“常量”
	节省内存，值不改变
	格式：		
		修饰词	static	final	类型	常量名=值;
	常量值不能改变，属于类本身
	一般所有字母大写，单词用下划线连接
				
-包package
	本质是一个文件夹
	是类的容器，用于存放相关的类
	定义包：
		packag 包名;
		命名规范：
			公司域名倒序.项目名.模块.功能名
			全部小写
		
-编译包中类
	所在目录cmd就好了
	
-运行包中类
	此时加载的完整类名是	包名.初始类名（相当于志明路径）
	解决：
		手动创建目录：
			在打开cmd的目录下手动创建包名的各层文件夹，
			并把编译后的字节码放在最后的文件夹
			再在当前目录cmd java 完整类名
		自动创建目录：
			编译：
				javac -d 编译后字节码存放的路径
				如：放在C盘的根目录下
					javac -d C:\
				放在当前目录：
					javac -d .*.java
			运行：
				java 完整类名

-一个类可以引用同一个包中的其他类（其实是同一目录下可以直接引用其他类）
	直接用初始类名创建对象（当然用完整类名创建也没有错）

-导入包package
	格式：
		import 完整类名;
		import 包名.*;
	编译时自动把*号变成具体类名，效率不低
	*号只能到类名级别，也就是说只会替换为当前目录下的类，当前目录下的文件夹不行
	注意：
		import应该放在package语句下，class语句上
	什么时候需要导入：
		不在同一个包下
		不在java.lang包
	使用src中util包（目录下）的Date类：
	如：import java.util.Date;或者
		import java.util.*;
	
-访问权限（大到小）
	public	任何位置都可以访问
	protected	同包（目录）或者其他包中的子类
	缺省（default）默认	同包
	private		本类

-修饰范围
	最大类和接口只能用public或者缺省来修饰，类中定义的类除外
	属性和方法四个都可以

-super关键字（和this对照着使用）
	本质：只代表对象的父类型特征，不是引用，不知向任何对象（所以不能return super;）this就可以
	解决父类子类同名问题
	使用：
		super.属性名;	访问父类中属性
		super.方法名（）;	调用父类中方法
		super.（实参）;		调用父类中构造方法，一般是有参构造，在子类创建前初始父类
			不提供则调用默认的super();
			不和this();同时出现在子类的构造方法中。因为2个都要求在构造方法第一行出现
			
-构造方法的作用：为了初始化对象的值

-对象可以作为参数

-对象只是一个数据类型，可以用数组存储
