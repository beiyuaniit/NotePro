-转型没用用new，因此没有创建新对象，但是原来的对象名（可能改变）
-抽象类
	语法：
		修饰符	abstract class 类名{}
	特点：
		无法实例化，无法创建对象，只能子类（也可以是抽象类）继承
			子类类型
				抽象的：可以不重写父类中的抽象方法
				非抽象：要重写父类中的抽象方法
		重写抽象方法也叫实现
		抽象类有构造方法，是给子类使用的
		不能和final连用，因为final修饰后无法继承

-抽象方法：
	语法：
		修饰符	abstract	返回值	方法名();
	特点：
		没有方法体
	
-关系
	抽象类中不一定有抽象方法，但是抽象方法只能出现在抽象类中

-面向抽象编程
	抽象是对类的抽想，是类的类。进一步降低了程序耦合度，提高扩展力

-抽象类的多态
	一致
	
-接口
	理解：
		是引用 数据类型，编译后是class文件
		完全抽象，（接口是半抽象的），可以说接口是特殊的抽象类
		相当于菜单，其子类相当于厨师，其使用者相当于顾客
		一般是对行为的抽象
	格式：
		修饰符	interface	接口名	{}
		
	语法：
		和抽象类差不多
		没有构造方法
		接口可以继承多个接口。
			如：interface	C extends A,B{}
		接口只能有常量和抽象方法
			所有常量public static final修饰，所有方法public	static心事，可以省略不写
		接口和接口间虽然没有继承关系，编译可以强制类型转换，但是运行时可能出现异常
			如果都是接口引用指向同一个此类而且没有调用其他接口的方法，运行时不会错
			所以用instanceof先判断类型然后在转换
-类实现接口
	class A implements B{}
	一个非抽象的类实现接口时，要实现（重写，覆盖）接口中所有抽象方法
	实现（继承也是一样），访问权限只能更高，不能更低，所以子类中实现的方法只能用public 而且不能省略
	
-面向接口编程
	接口引用指向子类对象（实际上还是多态）
	实现者面向接口实现，调用者面向接口调用
	
-一个类可以实现多个接口
	class A implements B,C{}
	弥补了类和类只支持单继承的缺点
	接口引用如何调用子类对象
		只能调用该接口中的方法
		要想调用其他类中的方法，要接口转型

-继承和实现同时出现
	class A extends B implements C{}
	
-所有类默认继承Object类，无论写没写

-面向抽象编程：父类
 面向接口编程：接口（实际上还是差不多）
	每一个接口都用调用者和实现者
	模板和模板之间通过接口衔接
-接口在开发中的作用
 可插拔
 
-关系（软件设计方面）
	is a//继承
	has a//属性
	A like a B（功能上）//接口
		B是接口，A是实现
		如：厨师像菜单
	
-包机制
	IDEA可以直接新建包（Alt+Insert）
	
	Scanner的解释
		java.util.Scanner s=new java.util.Scanner(System.in);
		String.str=s.next();
		导入包名
			import java.util.*;
			可以写为
				Scanner s=new Scanner(System.in);
		IDEA直接输入Scanner自动导入包（用自定义包中的类也可以）
	*通配符代表所有
	完整类名带有包名
	
-